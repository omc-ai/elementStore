<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ElementStore Admin</title>
    <link href="https://cdn.jsdelivr.net/npm/ag-grid-community@31/styles/ag-grid.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/ag-grid-community@31/styles/ag-theme-alpine.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 { font-size: 24px; font-weight: 600; }
        .header .actions { display: flex; gap: 10px; }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-sm { padding: 6px 12px; font-size: 12px; }
        .btn-xs { padding: 4px 8px; font-size: 11px; }
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover { background: #5a6fd6; }
        .btn-white { background: #fff; color: #667eea; }
        .btn-white:hover { background: #f0f0f0; }
        .btn-secondary { background: rgba(255,255,255,0.2); color: white; }
        .btn-secondary:hover { background: rgba(255,255,255,0.3); }
        .btn-ghost { background: #f3f4f6; color: #374151; }
        .btn-ghost:hover { background: #e5e7eb; }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover { background: #dc2626; }
        .btn-success { background: #10b981; color: white; }
        .btn-success:hover { background: #059669; }

        .container { padding: 20px 30px; }
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0;
        }
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
        }
        .tab:hover { color: #667eea; }
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 180px);
        }
        .card-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .card-header h2 { font-size: 16px; font-weight: 600; }
        .card-header .endpoint { font-size: 12px; color: #6b7280; font-family: 'Monaco', 'Menlo', monospace; margin-left: 12px; }
        .card-body { padding: 0; flex: 1; display: flex; flex-direction: column; overflow: hidden; }

        #gridContainer { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        #grid { flex: 1; width: 100%; min-height: 0; }

        /* Class Selector */
        .class-selector {
            padding: 16px 20px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 16px;
        }
        .class-selector label {
            font-weight: 500;
            font-size: 14px;
            color: #374151;
        }
        .class-selector .select2-container {
            min-width: 300px;
        }
        .select2-container--default .select2-selection--single {
            height: 38px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
        }
        .select2-container--default .select2-selection--single .select2-selection__rendered {
            line-height: 36px;
            padding-left: 12px;
        }
        .select2-container--default .select2-selection--single .select2-selection__arrow {
            height: 36px;
        }
        .select2-dropdown {
            border: 1px solid #d1d5db;
            border-radius: 6px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
        }
        .select2-results__option {
            padding: 8px 12px;
        }
        .select2-results__option--highlighted {
            background: #667eea !important;
        }
        /* Tree indentation for Select2 */
        .class-option { display: flex; align-items: center; gap: 8px; }
        .class-option .indent { color: #d1d5db; }
        .class-option .class-name { font-weight: 500; }
        .class-option .class-desc { color: #9ca3af; font-size: 12px; margin-left: 8px; }
        .class-option .extends-badge {
            font-size: 10px;
            background: #e0e7ff;
            color: #4338ca;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: #9ca3af;
        }
        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        .empty-state h3 {
            font-size: 16px;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 8px;
        }
        .empty-state p {
            font-size: 14px;
        }

        /* Modal - Draggable */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
            padding-top: 50px;
            overflow: auto;
        }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 900px;
            max-height: calc(100vh - 100px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
        }
        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            user-select: none;
            background: #f9fafb;
        }
        .modal-header h3 { font-size: 18px; font-weight: 600; }
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #9ca3af;
            line-height: 1;
        }
        .modal-close:hover { color: #6b7280; }
        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            background: #f9fafb;
        }

        /* Form */
        .form-group { margin-bottom: 16px; }
        .form-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 6px;
            color: #374151;
        }
        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }
        .form-input:read-only { background: #f3f4f6; cursor: not-allowed; }
        .form-textarea { min-height: 80px; resize: vertical; font-family: inherit; }
        .form-hint { font-size: 11px; color: #9ca3af; margin-top: 4px; }
        .form-row { display: flex; gap: 16px; }
        .form-row > * { flex: 1; }

        /* Property Editor */
        .prop-editor {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
        }
        .prop-editor-header {
            background: #f3f4f6;
            padding: 10px 16px;
            font-weight: 600;
            font-size: 13px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .prop-editor-body { padding: 16px; }
        .prop-row {
            display: flex;
            align-items: flex-start;
            margin-bottom: 12px;
            gap: 12px;
        }
        .prop-row:last-child { margin-bottom: 0; }
        .prop-key {
            min-width: 140px;
            font-size: 13px;
            font-weight: 500;
            color: #4b5563;
            padding-top: 10px;
        }
        .prop-key .type-badge {
            display: inline-block;
            font-size: 10px;
            font-weight: 400;
            color: #9ca3af;
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 6px;
        }
        .prop-value { flex: 1; }
        .prop-required { color: #ef4444; margin-left: 2px; }

        /* Property Groups */
        .prop-group {
            margin-bottom: 8px;
        }
        .prop-group-header {
            cursor: pointer;
            padding: 10px 16px;
            background: linear-gradient(135deg, #f0f4ff 0%, #f5f3ff 100%);
            margin: 16px -16px 12px -16px;
            border-top: 1px solid #e0e7ff;
            border-bottom: 1px solid #e0e7ff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        .prop-group-header:hover {
            background: linear-gradient(135deg, #e0e7ff 0%, #ede9fe 100%);
        }
        .prop-group-header .group-icon {
            display: inline-block;
            width: 16px;
            margin-right: 4px;
            transition: transform 0.2s;
        }
        .prop-group-content {
            padding: 0 4px;
        }
        .prop-row-wrapper {
            transition: opacity 0.2s, max-height 0.3s;
        }

        /* Array Editor */
        .array-editor {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px;
        }
        .array-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 8px;
            background: white;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }
        .array-item:last-child { margin-bottom: 0; }
        .array-index {
            min-width: 32px;
            font-size: 12px;
            color: #9ca3af;
            text-align: center;
            padding-top: 10px;
        }
        .array-item-content { flex: 1; }
        .array-item .form-input { flex: 1; }
        .array-actions { display: flex; gap: 4px; margin-top: 8px; }
        .array-item-remove { padding: 8px; align-self: flex-start; }

        /* Object Editor */
        .object-editor {
            background: #fefefe;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 12px;
            margin-top: 4px;
        }
        .object-editor .prop-row { margin-bottom: 10px; }
        .nested-level-1 { border-left: 3px solid #667eea; }
        .nested-level-2 { border-left: 3px solid #10b981; }
        .nested-level-3 { border-left: 3px solid #f59e0b; }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 26px;
            cursor: pointer;
        }
        .toggle-switch input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
            margin: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #d1d5db;
            border-radius: 26px;
            transition: 0.3s;
            pointer-events: none;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.3s;
        }
        .toggle-switch input:checked + .toggle-slider { background: #667eea; }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(22px); }

        /* Key-Value Editor */
        .keyvalue-editor {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 8px;
        }
        .keyvalue-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .keyvalue-row:last-child { margin-bottom: 0; }
        .keyvalue-key {
            flex: 0 0 100px;
        }
        .keyvalue-key input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        .keyvalue-value {
            flex: 1;
        }
        .keyvalue-value input, .keyvalue-value select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 12px;
        }
        .keyvalue-remove {
            padding: 4px 8px;
            background: #fee2e2;
            border: none;
            border-radius: 4px;
            color: #dc2626;
            cursor: pointer;
            font-size: 12px;
        }
        .keyvalue-remove:hover { background: #fecaca; }
        .keyvalue-actions {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e5e7eb;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 2000;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
        }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.success { background: #10b981; }
        .toast.error { background: #ef4444; }

        /* Validation */
        .form-input.invalid, .form-select.invalid, .form-textarea.invalid {
            border-color: #ef4444;
            background-color: #fef2f2;
        }
        .validation-error {
            color: #ef4444;
            font-size: 11px;
            margin-top: 4px;
            display: none;
        }
        .validation-error.show { display: block; }
        .prop-value { position: relative; }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #9ca3af;
        }
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #e5e7eb;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Relation Badge */
        .relation-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 6px;
            font-size: 13px;
        }
        .relation-badge button { padding: 2px 6px; font-size: 11px; }

        /* JSON Editor */
        .json-editor {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            min-height: 120px;
            background: #1e1e1e;
            color: #d4d4d4;
            border-radius: 6px;
        }

        /* JavaScript Code Editor */
        .code-editor {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            min-height: 150px;
            background: #1e1e1e;
            color: #d4d4d4;
            border-radius: 6px;
            tab-size: 2;
            white-space: pre;
            overflow-x: auto;
        }
        .code-editor::placeholder {
            color: #6a6a6a;
        }

        /* JSON Preview Toggle */
        .btn-json-toggle {
            background: none;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 10px;
            font-family: 'Monaco', 'Menlo', monospace;
            color: #6b7280;
            cursor: pointer;
            margin-left: 6px;
            vertical-align: middle;
        }
        .btn-json-toggle:hover {
            background: #f3f4f6;
            color: #374151;
        }
        .btn-json-toggle.active {
            background: #e0e7ff;
            border-color: #667eea;
            color: #4338ca;
        }
        .prop-json-preview {
            margin-bottom: 8px;
            background: #1e1e1e;
            border-radius: 6px;
            overflow: hidden;
        }
        .json-preview-code {
            margin: 0;
            padding: 10px 12px;
            font-size: 11px;
            font-family: 'Monaco', 'Menlo', monospace;
            color: #9cdcfe;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
        }

        /* Export History */
        .export-list { list-style: none; }
        .export-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb;
            gap: 16px;
        }
        .export-item:last-child { border-bottom: none; }
        .export-item:hover { background: #f9fafb; }
        .export-hash {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            background: #e0e7ff;
            color: #4338ca;
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 100px;
            text-align: center;
        }
        .export-info { flex: 1; }
        .export-date { font-size: 13px; color: #374151; font-weight: 500; }
        .export-stats { font-size: 12px; color: #6b7280; margin-top: 2px; }
        .export-size { font-size: 11px; color: #9ca3af; }
        .export-actions { display: flex; gap: 6px; }
        .export-empty {
            text-align: center;
            padding: 40px;
            color: #9ca3af;
        }
        .export-empty svg {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        /* Tag Select (Select2-like multi-select) */
        .tag-select-container {
            position: relative;
        }
        .tag-select {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: #fff;
            min-height: 36px;
            cursor: text;
        }
        .tag-select:focus-within {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }
        .tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            background: #e0e7ff;
            color: #4338ca;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        .tag-remove {
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            opacity: 0.6;
        }
        .tag-remove:hover { opacity: 1; }
        .tag-input {
            flex: 1;
            min-width: 60px;
            border: none;
            outline: none;
            padding: 4px;
            font-size: 13px;
            background: transparent;
        }
        .tag-select-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }
        .tag-select-dropdown.open { display: block; }
        .tag-select-option {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
        }
        .tag-select-option:hover,
        .tag-select-option.highlighted { background: #f3f4f6; }
        .tag-select-option.selected {
            background: #e0e7ff;
            color: #4338ca;
        }

        /* Property Table Layout */
        .prop-table {
            width: 100%;
            border-collapse: collapse;
        }
        .prop-table td {
            padding: 6px 10px;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: top;
        }
        .prop-name {
            width: 160px;
            min-width: 100px;
            font-size: 12px;
            font-weight: 500;
            color: #374151;
            background: #f9fafb;
            padding-top: 10px;
            position: relative;
        }
        .prop-edit {
            font-size: 12px;
        }
        .prop-nested {
            padding: 0 !important;
            background: #fafbfc;
        }
        /* Tree-like structure for nested items */
        .prop-nested-row {
            display: flex;
        }
        .prop-nested-fold {
            width: 24px;
            min-width: 24px;
            background: #f0f0f0;
            border-right: 1px solid #e0e0e0;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 6px;
        }
        .prop-nested-main {
            flex: 1;
            min-width: 0;
        }
        .prop-nested-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            font-size: 11px;
            font-weight: 500;
            color: #495057;
        }
        .prop-nested-content {
            padding: 0;
        }
        .prop-group-header {
            background: #f3f4f6;
            font-weight: 600;
            font-size: 12px;
            color: #6b7280;
            cursor: pointer;
            user-select: none;
        }
        .prop-group-header:hover { background: #e5e7eb; }
        .group-icon {
            display: inline-block;
            width: 16px;
            transition: transform 0.2s;
        }
        .prop-group-row.collapsed .group-icon { transform: rotate(-90deg); }
        .type-badge {
            font-size: 10px;
            font-weight: normal;
            color: #9ca3af;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        /* =====================================================
           GENERIC EDITOR (GE) - Minimal table-based layout
           ===================================================== */
        .ge { width: 100%; border-collapse: collapse; table-layout: fixed; }
        .ge td { padding: 4px 8px; vertical-align: top; border-bottom: 1px solid #eee; }
        .ge-key {
            padding-top: 8px;
            width: 180px;
            min-width: 100px;
            background: #fafafa;
            font-size: 12px;
            font-weight: 500;
            color: #374151;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            position: relative;
            border-right: 1px solid #e5e7eb;
        }
        .ge-key .t { color: #9ca3af; font-weight: 400; font-size: 10px; margin-left: 4px; }
        .ge-key .req { color: #ef4444; }
        .ge-val { font-size: 13px; }
        /* Column resizer */
        .ge-resizer {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: col-resize;
            background: transparent;
            z-index: 10;
        }
        .ge-resizer:hover, .ge-resizer.active { background: #667eea; }
        .ge-val input, .ge-val select, .ge-val textarea {
            width: 100%;
            padding: 6px 8px;
            border: none;
            background: transparent;
            font-size: 13px;
        }
        .ge-val input:focus, .ge-val select:focus, .ge-val textarea:focus {
            outline: none; background: #f8fafc;
        }
        .ge-val input[readonly] { color: #6b7280; cursor: default; }
        /* Prop meta button */
        .ge-key .ge-meta-btn {
            opacity: 0;
            margin-left: 4px;
            padding: 1px 4px;
            font-size: 9px;
            background: #e0e7ff;
            color: #4338ca;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            transition: opacity 0.15s;
        }
        .ge tr:hover .ge-meta-btn { opacity: 0.7; }
        .ge-meta-btn:hover { opacity: 1 !important; background: #c7d2fe; }
        .ge-val textarea { min-height: 60px; font-family: inherit; resize: vertical; }
        .ge-val textarea.code {
            font-family: 'Monaco','Menlo',monospace;
            font-size: 12px;
            background: #1e1e1e;
            color: #d4d4d4;
            min-height: 100px;
        }
        /* Nested object/array - new row layout */
        .ge-nest-row td { padding: 0 !important; border-bottom: none; }
        .ge-nest-indent {
            width: 28px;
            min-width: 28px;
            background: #f8fafc;
            border-right: 3px solid #667eea;
            text-align: center;
            padding-top: 6px !important;
        }
        .ge-nest-indent.l1 { border-right-color: #667eea; }
        .ge-nest-indent.l2 { border-right-color: #10b981; }
        .ge-nest-indent.l3 { border-right-color: #f59e0b; }
        .ge-nest-content { padding: 0 !important; background: #fafbfc; }
        .ge-nest-content.collapsed { display: none; }
        /* Fold toggle button */
        .ge-fold {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border: 1px solid #6c757d;
            background: #495057;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            line-height: 1;
        }
        .ge-fold:hover { background: #343a40; }
        .ge-fold.collapsed { background: #667eea; border-color: #5a6fd6; }
        /* Array header inline */
        .ge-arr-inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #92400e;
        }
        .ge-arr-inline .count {
            background: #fef3c7;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
        }
        /* Object header inline */
        .ge-obj-inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #4338ca;
        }
        .ge-obj-inline .cls {
            background: #e0e7ff;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
        }
        /* Array item in nested row */
        .ge-arr-item {
            margin: 4px 0;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            background: #fff;
        }
        .ge-arr-item-hdr {
            padding: 4px 10px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .ge-arr-item-hdr .left {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .ge-arr-item-hdr .idx {
            font-weight: 600;
            color: #6b7280;
            background: #e5e7eb;
            padding: 1px 6px;
            border-radius: 3px;
        }
        .ge-arr-item-body { padding: 0; }
        .ge-arr-item-body .ge { margin: 0; }
        /* Collapsed state */
        .ge-arr-item.collapsed .ge-arr-item-body { display: none; }
        .ge-arr-item.collapsed .ge-arr-item-hdr { border-bottom: none; }
        .ge-btn {
            padding: 2px 8px;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }
        .ge-btn-add { background: #dcfce7; color: #166534; }
        .ge-btn-add:hover { background: #bbf7d0; }
        .ge-btn-del { background: #fee2e2; color: #dc2626; }
        .ge-btn-del:hover { background: #fecaca; }
        /* Toggle */
        .ge-toggle { display: inline-flex; align-items: center; gap: 8px; }
        .ge-toggle input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        .ge-toggle-label { font-size: 12px; color: #6b7280; }
        /* Relation select */
        .ge-rel { display: flex; gap: 6px; align-items: center; }
        .ge-rel select { flex: 1; }
        .ge-rel-info { font-size: 10px; color: #9ca3af; }
        /* Combo box (select + custom text input) */
        .ge-combo { display: flex; flex-direction: column; gap: 4px; }
        .ge-combo select { width: 100%; }
        .ge-combo-custom { width: 100%; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px; }
        /* Unique constraints editor */
        .ge-unique { padding: 8px; background: #f9fafb; border-radius: 4px; }
        .ge-unique-list { margin-bottom: 8px; }
        .ge-unique-item { margin-bottom: 8px; padding: 8px; background: #fff; border: 1px solid #e5e7eb; border-radius: 4px; }
        .ge-unique-item-hdr { display: flex; gap: 8px; margin-bottom: 6px; }
        .ge-unique-id { flex: 1; padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 3px; font-size: 12px; }
        .ge-unique-fields { display: flex; flex-wrap: wrap; gap: 4px; align-items: center; }
        .ge-unique-field { display: flex; gap: 4px; align-items: center; background: #f3f4f6; padding: 2px 4px; border-radius: 3px; }
        .ge-unique-field select, .ge-unique-field input { padding: 2px 6px; font-size: 11px; border: 1px solid #d1d5db; border-radius: 2px; }
        .ge-unique-field-type { width: 70px; }
        .ge-unique-field-val { min-width: 80px; }
        .ge-btn-sm { padding: 0 4px; font-size: 12px; background: none; border: none; color: #9ca3af; cursor: pointer; }
        .ge-btn-sm:hover { color: #ef4444; }
        .ge-unique-empty { font-size: 11px; color: #9ca3af; font-style: italic; padding: 4px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ElementStore Admin</h1>
        <div class="actions">
            <button class="btn btn-secondary" onclick="exportData()">Export</button>
            <button class="btn btn-secondary" onclick="showExportHistory()">History</button>
            <button class="btn btn-danger" onclick="resetDatabase()">Reset DB</button>
            <button class="btn btn-secondary" onclick="refreshData()">Refresh</button>
        </div>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" data-tab="classes">Classes (@class)</button>
            <button class="tab" data-tab="objects">Objects</button>
        </div>

        <div class="card">
            <div class="card-header">
                <div style="display:flex;align-items:center">
                    <h2 id="cardTitle">Class Definitions</h2>
                    <span id="cardEndpoint" class="endpoint">GET /class</span>
                </div>
                <div id="cardActions">
                    <button class="btn btn-primary btn-sm" onclick="openCreateModal()">+ New Class</button>
                </div>
            </div>
            <!-- Class Selector (shown only on Objects tab) -->
            <div class="class-selector" id="classSelector" style="display:none;">
                <label for="classSelect">Select Class:</label>
                <select id="classSelect" style="width: 350px;"></select>
            </div>
            <div class="card-body">
                <div id="gridContainer">
                    <div id="grid" class="ag-theme-alpine"></div>
                </div>
                <div id="emptyState" class="empty-state" style="display:none;">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" />
                    </svg>
                    <h3>Select a class to view objects</h3>
                    <p>Use the dropdown above to choose a class</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Universal Edit Modal -->
    <div class="modal-overlay" id="editModal">
        <div class="modal" id="editModalContent">
            <div class="modal-header" onmousedown="startDrag(event, 'editModalContent')">
                <h3 id="modalTitle">Edit</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody"></div>
            <div class="modal-footer">
                <button type="button" class="btn btn-ghost" onclick="closeModal()">Cancel</button>
                <button type="button" class="btn btn-success" id="saveBtn" onclick="saveCurrentObject()">Save</button>
            </div>
        </div>
    </div>

    <!-- Export History Modal -->
    <div class="modal-overlay" id="historyModal">
        <div class="modal" id="historyModalContent" style="max-width: 700px;">
            <div class="modal-header" onmousedown="startDrag(event, 'historyModalContent')">
                <h3>Export History</h3>
                <button class="modal-close" onclick="closeHistoryModal()">&times;</button>
            </div>
            <div class="modal-body" id="historyBody">
                <div class="loading"><div class="spinner"></div>Loading...</div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-ghost" onclick="closeHistoryModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community@31/dist/ag-grid-community.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script>
        const API_BASE = '/elementStore';
        let gridApi = null;
        let currentTab = 'classes';
        let currentClassId = null;
        let currentClassMeta = null;
        let editingClassId = null;
        let editingObject = null;
        let classesCache = {};
        let classTreeData = [];
        let allClassesList = [];  // Raw list of all classes for relation editors
        let currentGridData = [];  // Store current grid data for lookup (avoids inline JSON issues)

        // New data types - removed 'number', 'date', 'datetime', 'enum' (deprecated)
        // Note: 'unique' is NOT a data_type - it's a class-level constraint array
        const DATA_TYPES = ['string', 'boolean', 'float', 'integer', 'object', 'relation', 'function'];

        // Legacy data types for backward compatibility display
        const LEGACY_DATA_TYPES = ['number', 'date', 'datetime', 'enum'];

        // Data types that show conditional relation fields
        const RELATION_TYPES = ['object', 'relation'];

        // Data types that have special options editor
        const OPTIONS_TYPES = {
            'string': 'string_options',
            'integer': 'number_options',
            'float': 'number_options',
            'boolean': 'boolean_options',
            'object': 'object_options',
            'relation': 'relation_options',
            'unique': 'unique_options',
            'function': 'function_options'
        };

        // Store @function definitions for function type editors
        let functionConfig = {
            functions: {},  // Map of function id -> function definition
            typeMap: {},    // Map of function_type -> [function ids]
            loaded: false
        };

        // Editor configuration (static - could be moved to @editor-config class later)
        const EDITOR_CONFIG = {
            data_types: {
                string: { default: 'text', editors: ['text', 'textarea', 'code', 'json'] },
                number: { default: 'number', editors: ['number', 'slider'] },
                float: { default: 'number', editors: ['number', 'slider'] },
                boolean: { default: 'toggle', editors: ['toggle', 'checkbox'] },
                date: { default: 'date', editors: ['date'] },
                datetime: { default: 'datetime', editors: ['datetime'] },
                enum: { default: 'select', editors: ['select'] },
                object: { default: 'json', editors: ['json', 'keyvalue'] },
                relation: { default: 'reference', editors: ['reference'] }
            },
            editors: {
                text: { label: 'Text Input' },
                textarea: { label: 'Text Area' },
                number: { label: 'Number' },
                slider: { label: 'Slider' },
                toggle: { label: 'Toggle' },
                checkbox: { label: 'Checkbox' },
                select: { label: 'Select' },
                date: { label: 'Date' },
                datetime: { label: 'DateTime' },
                code: { label: 'Code' },
                json: { label: 'JSON' },
                keyvalue: { label: 'Key-Value' },
                reference: { label: 'Reference' }
            }
        };

        // Get available editors for a data type
        function getEditorsForDataType(dataType) {
            const config = EDITOR_CONFIG.data_types[dataType];
            return config ? config.editors : ['text'];
        }

        // =====================
        // Field Validation
        // =====================
        // Store current props for validation lookup
        let currentFormProps = {};

        function validateField(input) {
            const propKey = input.dataset.prop || input.dataset.nested?.split('.').pop();
            if (!propKey) return true;

            const prop = currentFormProps[propKey];
            if (!prop) return true;

            const value = input.type === 'checkbox' ? input.checked : input.value;
            const errors = [];

            // Required check
            if (prop.required && (value === '' || value === undefined || value === null)) {
                errors.push(`${prop.label || propKey} is required`);
            }

            // Skip other validations if empty and not required
            if (value === '' || value === undefined || value === null) {
                clearValidationError(input);
                return true;
            }

            // Email validation
            const validators = prop.validators || [];
            if (validators.some(v => v.type === 'email') || propKey === 'email') {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(value)) {
                    errors.push('Invalid email address');
                }
            }

            // URL validation
            if (validators.some(v => v.type === 'url')) {
                try {
                    new URL(value);
                } catch {
                    errors.push('Invalid URL');
                }
            }

            // Enum validation (from data_type or validators)
            if (prop.data_type === 'enum' && prop.enum_values?.length > 0) {
                if (!prop.enum_values.includes(value)) {
                    errors.push(`Must be one of: ${prop.enum_values.join(', ')}`);
                }
            }
            const enumValidator = validators.find(v => v.type === 'enum');
            if (enumValidator?.values?.length > 0) {
                if (!enumValidator.values.includes(value)) {
                    errors.push(`Must be one of: ${enumValidator.values.join(', ')}`);
                }
            }

            // Number validation
            if ((prop.data_type === 'number' || prop.data_type === 'float') && value !== '') {
                if (isNaN(parseFloat(value))) {
                    errors.push('Must be a number');
                }
            }

            // Min/Max validation
            const minValidator = validators.find(v => v.type === 'min' || v.type === 'range');
            const maxValidator = validators.find(v => v.type === 'max' || v.type === 'range');
            if (minValidator?.min !== undefined && parseFloat(value) < minValidator.min) {
                errors.push(`Minimum value is ${minValidator.min}`);
            }
            if (maxValidator?.max !== undefined && parseFloat(value) > maxValidator.max) {
                errors.push(`Maximum value is ${maxValidator.max}`);
            }

            // Length validation
            const lengthValidator = validators.find(v => v.type === 'length');
            if (lengthValidator) {
                if (lengthValidator.min && value.length < lengthValidator.min) {
                    errors.push(`Minimum length is ${lengthValidator.min}`);
                }
                if (lengthValidator.max && value.length > lengthValidator.max) {
                    errors.push(`Maximum length is ${lengthValidator.max}`);
                }
            }

            // Show or clear error
            if (errors.length > 0) {
                showValidationError(input, errors[0]);
                return false;
            } else {
                clearValidationError(input);
                return true;
            }
        }

        function showValidationError(input, message) {
            input.classList.add('invalid');
            let errorEl = input.parentElement.querySelector('.validation-error');
            if (!errorEl) {
                errorEl = document.createElement('div');
                errorEl.className = 'validation-error';
                input.parentElement.appendChild(errorEl);
            }
            errorEl.textContent = message;
            errorEl.classList.add('show');
        }

        function clearValidationError(input) {
            input.classList.remove('invalid');
            const errorEl = input.parentElement.querySelector('.validation-error');
            if (errorEl) {
                errorEl.classList.remove('show');
            }
        }

        function validateAllFields() {
            let isValid = true;
            document.querySelectorAll('[data-prop]').forEach(input => {
                if (!validateField(input)) {
                    isValid = false;
                }
            });
            return isValid;
        }

        // =====================
        // Drag functionality
        // =====================
        let dragState = { active: false, modal: null, startX: 0, startY: 0, initialX: 0, initialY: 0 };

        function startDrag(e, modalId) {
            const modal = document.getElementById(modalId);
            if (!modal) return;
            dragState.active = true;
            dragState.modal = modal;
            dragState.startX = e.clientX;
            dragState.startY = e.clientY;
            const rect = modal.getBoundingClientRect();
            dragState.initialX = rect.left;
            dragState.initialY = rect.top;
            modal.style.position = 'fixed';
            modal.style.left = rect.left + 'px';
            modal.style.top = rect.top + 'px';
            modal.style.margin = '0';
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
            e.preventDefault();
        }

        function onDrag(e) {
            if (!dragState.active) return;
            const dx = e.clientX - dragState.startX;
            const dy = e.clientY - dragState.startY;
            dragState.modal.style.left = (dragState.initialX + dx) + 'px';
            dragState.modal.style.top = (dragState.initialY + dy) + 'px';
        }

        function stopDrag() {
            dragState.active = false;
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // =====================
        // API helpers
        // =====================
        async function api(method, endpoint, data = null) {
            const opts = {
                method,
                headers: {
                    'Content-Type': 'application/json',
                    'X-Disable-Ownership': 'true',
                    'X-Allow-Custom-Ids': 'true'
                }
            };
            if (data) opts.body = JSON.stringify(data);
            const res = await fetch(API_BASE + endpoint, opts);
            const json = await res.json();
            if (json.error) throw new Error(json.error);
            return json;
        }

        async function getClassMeta(classId) {
            if (classesCache[classId]) return classesCache[classId];
            try {
                // Fetch class metadata and inherited props in parallel
                const [meta, inheritedProps] = await Promise.all([
                    api('GET', `/class/${classId}`),
                    api('GET', `/class/${classId}/props`)  // Includes inherited props
                ]);

                // Replace props with inherited props (which include parent class props)
                meta.props = inheritedProps;

                classesCache[classId] = meta;
                return meta;
            } catch (e) {
                return null;
            }
        }

        // =====================
        // JSON Preview Toggle
        // =====================
        function togglePropJson(btn) {
            const propRow = btn.closest('.prop-row');
            const preview = propRow.querySelector('.prop-json-preview');
            if (preview) {
                const isHidden = preview.style.display === 'none';
                preview.style.display = isHidden ? 'block' : 'none';
                btn.classList.toggle('active', isHidden);
            }
        }

        function toggleAllPropJson(show) {
            document.querySelectorAll('.prop-json-preview').forEach(el => {
                el.style.display = show ? 'block' : 'none';
            });
            document.querySelectorAll('.btn-json-toggle').forEach(btn => {
                btn.classList.toggle('active', show);
            });
        }

        function toggleMetaViewer() {
            const content = document.getElementById('metaViewerContent');
            const icon = document.getElementById('metaViewerIcon');
            if (content && icon) {
                const isHidden = content.style.display === 'none';
                content.style.display = isHidden ? 'block' : 'none';
                icon.textContent = isHidden ? '▼' : '▶';
            }
        }

        // =====================
        // Toast notifications
        // =====================
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // =====================
        // Modal helpers
        // =====================
        function openModal() {
            const modal = document.getElementById('editModal');
            modal.classList.add('active');
            const content = modal.querySelector('.modal');
            if (content) {
                content.style.position = '';
                content.style.left = '';
                content.style.top = '';
                content.style.margin = '';
            }
        }

        function closeModal() {
            document.getElementById('editModal').classList.remove('active');
            editingObject = null;
            editingClassId = null;
        }

        // =====================
        // Build Class Tree for Select2
        // =====================
        function buildClassTree(classes) {
            // Filter out system classes (starting with @)
            const userClasses = classes.filter(c => !c.id.startsWith('@'));

            // Build parent-child map
            const childrenMap = {};
            const rootClasses = [];

            userClasses.forEach(c => {
                if (c.extends_id && !c.extends_id.startsWith('@')) {
                    if (!childrenMap[c.extends_id]) childrenMap[c.extends_id] = [];
                    childrenMap[c.extends_id].push(c);
                } else {
                    rootClasses.push(c);
                }
            });

            // Recursively build tree data
            function buildNode(cls, level) {
                const indent = '│  '.repeat(level);
                const prefix = level > 0 ? '├─ ' : '';
                const node = {
                    id: cls.id,
                    text: cls.id,
                    name: cls.name || cls.id,
                    description: cls.description || '',
                    extends_id: cls.extends_id || '',
                    level: level,
                    indent: indent + prefix
                };

                const children = childrenMap[cls.id] || [];
                const result = [node];

                children.forEach((child, idx) => {
                    result.push(...buildNode(child, level + 1));
                });

                return result;
            }

            let treeData = [];
            rootClasses.forEach(cls => {
                treeData.push(...buildNode(cls, 0));
            });

            return treeData;
        }

        function initClassSelector() {
            const $select = $('#classSelect');

            $select.select2({
                placeholder: 'Search and select a class...',
                allowClear: true,
                data: classTreeData.map(c => ({
                    id: c.id,
                    text: c.id,
                    name: c.name,
                    description: c.description,
                    extends_id: c.extends_id,
                    level: c.level,
                    indent: c.indent
                })),
                templateResult: formatClassOption,
                templateSelection: formatClassSelection,
                matcher: classSearchMatcher
            });

            $select.on('select2:select', function(e) {
                const classId = e.params.data.id;
                if (classId) {
                    loadObjects(classId);
                }
            });

            $select.on('select2:clear', function() {
                showEmptyState();
            });
        }

        function formatClassOption(item) {
            if (!item.id) return item.text;

            const $container = $('<div class="class-option"></div>');

            if (item.indent) {
                $container.append(`<span class="indent">${item.indent}</span>`);
            }

            $container.append(`<span class="class-name">${item.id}</span>`);

            if (item.name && item.name !== item.id) {
                $container.append(`<span class="class-desc">(${item.name})</span>`);
            }

            if (item.extends_id) {
                $container.append(`<span class="extends-badge">extends: ${item.extends_id}</span>`);
            }

            return $container;
        }

        function formatClassSelection(item) {
            if (!item.id) return item.text;
            return item.id + (item.name && item.name !== item.id ? ` (${item.name})` : '');
        }

        function classSearchMatcher(params, data) {
            if (!params.term || params.term.trim() === '') {
                return data;
            }

            const term = params.term.toLowerCase();
            const id = (data.id || '').toLowerCase();
            const name = (data.name || '').toLowerCase();
            const desc = (data.description || '').toLowerCase();

            if (id.includes(term) || name.includes(term) || desc.includes(term)) {
                return data;
            }

            return null;
        }

        function showEmptyState() {
            document.getElementById('gridContainer').style.display = 'none';
            document.getElementById('emptyState').style.display = 'flex';
            document.getElementById('cardActions').innerHTML = '';
            document.getElementById('cardTitle').textContent = 'Objects';
            document.getElementById('cardEndpoint').textContent = '';
            currentClassId = null;
            currentClassMeta = null;
        }

        // =====================
        // Grid initialization
        // =====================
        function initGrid(columnDefs, rowData) {
            const gridDiv = document.getElementById('grid');
            gridDiv.innerHTML = '';
            document.getElementById('gridContainer').style.display = 'flex';
            document.getElementById('emptyState').style.display = 'none';

            // Store data for lookup (avoids inline JSON issues in onclick)
            currentGridData = rowData || [];

            const gridOptions = {
                columnDefs,
                rowData,
                defaultColDef: {
                    sortable: true,
                    filter: true,
                    resizable: true,
                    flex: 1,
                    minWidth: 100
                },
                rowSelection: 'single',
                onRowDoubleClicked: (e) => openEditModal(e.data),
                animateRows: true,
                pagination: true,
                paginationPageSize: 20
            };

            gridApi = agGrid.createGrid(gridDiv, gridOptions);
        }

        // Edit by row index (called from grid buttons)
        function editRowByIndex(idx) {
            if (currentGridData[idx]) {
                openEditModal(currentGridData[idx]);
            }
        }

        // =====================
        // Load @function objects from API
        // =====================
        async function loadFunctions() {
            try {
                const functions = await api('GET', '/store/@function');
                functionConfig.functions = {};
                functionConfig.typeMap = {};

                for (const func of functions) {
                    functionConfig.functions[func.id] = func;

                    // Build function_type -> functions mapping
                    const funcType = func.function_type || 'custom';
                    if (!functionConfig.typeMap[funcType]) {
                        functionConfig.typeMap[funcType] = [];
                    }
                    functionConfig.typeMap[funcType].push(func.id);
                }

                functionConfig.loaded = true;
                console.log('Loaded', Object.keys(functionConfig.functions).length, 'functions from @function');
            } catch (e) {
                console.warn('Failed to load @function objects:', e.message);
                functionConfig.loaded = true; // Mark as loaded even if empty
            }
        }

        // Get functions by type (validator, transformer, generator, computed, custom)
        function getFunctionsByType(funcType) {
            return functionConfig.typeMap[funcType] || [];
        }

        // Get function definition by id
        function getFunctionDef(funcId) {
            return functionConfig.functions[funcId] || null;
        }

        // =====================
        // Generic: Load objects of any class (unified function)
        // =====================
        async function loadObjectsOfClass(classId) {
            try {
                currentClassId = classId;
                const isClassTab = classId === '@class';

                // Fetch class meta and objects
                const [classMeta, objects] = await Promise.all([
                    getClassMeta(classId),
                    isClassTab ? api('GET', '/class') : api('GET', `/store/${classId}`)
                ]);
                currentClassMeta = classMeta;

                // If loading @class, also update the class lists for selectors
                if (isClassTab) {
                    allClassesList = objects;
                    classesCache = {};
                    classTreeData = buildClassTree(objects);
                }

                // Update UI
                const displayName = classMeta?.name || classId;
                document.getElementById('cardTitle').textContent = displayName;
                document.getElementById('cardEndpoint').textContent = isClassTab ? 'GET /class' : `GET /store/${classId}`;
                document.getElementById('cardActions').innerHTML = `
                    <button class="btn btn-primary btn-sm" onclick="openCreateModal()">+ New ${displayName}</button>
                `;
                document.getElementById('gridContainer').style.display = 'flex';
                document.getElementById('emptyState').style.display = 'none';

                // Build column definitions from class meta using elementStore
                const propsArray = classMeta ? elementStore.getSortedProps(classMeta) : [];

                const columnDefs = [
                    { field: 'id', headerName: 'ID', width: 150, pinned: 'left' }
                ];

                // Add columns for each property using elementStore.propToCell
                propsArray.forEach(prop => {
                    // Skip 'props' array - we'll add a count column instead
                    if (prop.key === 'props') return;

                    const colDef = {
                        field: prop.key,
                        headerName: elementStore.getPropLabel(prop),
                        width: 150,
                        // Use elementStore.propToCell for consistent cell rendering
                        cellRenderer: (p) => elementStore.propToCell(prop, p.value, p.data.id)
                    };

                    // Adjust width based on type
                    if (prop.data_type === 'boolean') {
                        colDef.width = 80;
                    } else if (prop.is_array) {
                        colDef.width = 70;
                    }

                    columnDefs.push(colDef);
                });

                // Add props count column if class has props array (like @class)
                if (propsArray.find(p => p.key === 'props')) {
                    columnDefs.push({
                        field: 'props',
                        headerName: 'Props',
                        cellRenderer: (p) => {
                            const props = p.data.props || {};
                            return Array.isArray(props) ? props.length : Object.keys(props).length;
                        },
                        width: 70
                    });
                }

                // Add Actions column
                const actionsWidth = isClassTab ? 180 : 120;
                columnDefs.push({
                    headerName: 'Actions',
                    width: actionsWidth,
                    pinned: 'right',
                    cellRenderer: (p) => {
                        let html = `<button class="btn btn-ghost btn-xs" onclick="editRowByIndex(${p.rowIndex})">Edit</button>`;
                        // For @class, add "Objects" button to view instances
                        if (isClassTab) {
                            html += `<button class="btn btn-primary btn-xs" style="margin-left:4px" onclick="viewObjectsOfClass('${p.data.id}')">Objects</button>`;
                        }
                        html += `<button class="btn btn-danger btn-xs" style="margin-left:4px" onclick="deleteItem('${p.data.id}')">Del</button>`;
                        return html;
                    }
                });

                initGrid(columnDefs, objects);
            } catch (err) {
                showToast(err.message, 'error');
            }
        }

        // Legacy wrapper for loadClasses
        function loadClasses() {
            document.getElementById('classSelector').style.display = 'none';
            loadObjectsOfClass('@class');
        }

        // Legacy wrapper for loadObjects
        function loadObjects(classId) {
            loadObjectsOfClass(classId);
        }

        // =====================
        // View objects for a class (from @class tab "Objects" button)
        // =====================
        async function viewObjectsOfClass(classId) {
            currentTab = 'objects';
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-tab=objects]').classList.add('active');

            await showObjectsTab();

            // Set the selector value and load objects
            $('#classSelect').val(classId).trigger('change');
            loadObjectsOfClass(classId);
        }

        // =====================
        // Show Objects Tab (setup selector)
        // =====================
        async function showObjectsTab() {
            document.getElementById('classSelector').style.display = 'flex';

            // Ensure classes tree is loaded for selector
            if (classTreeData.length === 0) {
                const classes = await api('GET', '/class');
                allClassesList = classes;
                classTreeData = buildClassTree(classes);
            }

            // Initialize Select2
            const $select = $('#classSelect');
            if ($select.hasClass('select2-hidden-accessible')) {
                $select.select2('destroy');
            }
            $select.empty();

            const selectData = classTreeData.map(c => ({
                id: c.id,
                text: c.id,
                name: c.name,
                description: c.description,
                extends_id: c.extends_id,
                level: c.level,
                indent: c.indent
            }));

            $select.select2({
                placeholder: 'Search and select a class...',
                allowClear: true,
                data: selectData,
                templateResult: formatClassOption,
                templateSelection: formatClassSelection,
                matcher: classSearchMatcher
            });

            $select.off('select2:select').on('select2:select', function(e) {
                const classId = e.params.data.id;
                if (classId) loadObjectsOfClass(classId);
            });

            $select.off('select2:clear').on('select2:clear', function() {
                showEmptyState();
            });
        }

        // =====================
        // Open Create Modal (generic for any class)
        // =====================
        async function openCreateModal() {
            if (!currentClassId) {
                showToast('Please select a class first', 'error');
                return;
            }
            editingClassId = currentClassId;
            editingObject = { id: '' };  // Empty object, ID will be editable

            const meta = await getClassMeta(currentClassId);
            const displayName = meta?.name || currentClassId;
            document.getElementById('modalTitle').textContent = `Create New ${displayName}`;

            await renderPropertyEditor();
            openModal();
        }

        // =====================
        // Open Edit Modal (generic for any class)
        // =====================
        async function openEditModal(data) {
            editingClassId = currentClassId;
            editingObject = data;

            const meta = await getClassMeta(currentClassId);
            const displayName = meta?.name || currentClassId;
            document.getElementById('modalTitle').textContent = `Edit ${displayName}: ${data.id}`;

            await renderPropertyEditor();
            openModal();
        }

        // =====================================================
        // GENERIC EDITOR (GE) - Recursive table-based editor
        // Renders any object based on its class @props
        // =====================================================

        /**
         * Main entry: Render generic editor for a class (delegates to elementStore)
         * @param {string} classId - Class ID
         * @param {object} data - Object data to edit
         * @returns {Promise<string>} HTML
         */
        async function renderGenericEditor(classId, data) {
            return elementStore.renderEditor(classId, data);
        }

        // =====================================================================
        // ELEMENT STORE NAMESPACE - Unified prop helpers
        // Usage: elementStore.getCls(prop), elementStore.getPropsTable(meta, obj, path, lvl)
        // =====================================================================

        const elementStore = {
            /** Extract class ID from prop (handles array format) */
            getCls(prop) {
                return Array.isArray(prop.object_class_id) ? prop.object_class_id[0] : prop.object_class_id;
            },

            /** Generate fold ID from path */
            getFoldId(path) {
                return `fold_${path.replace(/[\[\].]/g, '_')}`;
            },

            /** Get sorted props from class meta */
            getSortedProps(meta) {
                const props = Array.isArray(meta.props) ? meta.props : Object.values(meta.props || {});
                return [...props].sort((a, b) => (a.display_order || 0) - (b.display_order || 0));
            },

            /** Get display label for prop */
            getPropLabel(prop) {
                return prop.label || prop.key;
            },

            /** Build type badge text (e.g., "object → user[]") */
            getPropType(prop) {
                const dt = prop.data_type || 'string';
                const cls = this.getCls(prop);
                let label = dt;
                if (cls) label = `${dt} → ${cls}`;
                if (prop.is_array) label += '[]';
                return label;
            },

            /** Render prop as table column header */
            propToHeader(prop) {
                return `<th data-key="${prop.key}" data-type="${prop.data_type || 'string'}">
                    ${esc(this.getPropLabel(prop))}
                    <span class="type-badge">${this.getPropType(prop)}</span>
                </th>`;
            },

            /** Render prop value as table cell */
            propToCell(prop, value, objId) {
                const dt = prop.data_type || 'string';
                const cls = this.getCls(prop);
                const opts = prop.options || {};

                // Boolean with optional custom labels
                if (dt === 'boolean') {
                    const labels = opts.true_label && opts.false_label
                        ? { t: opts.true_label, f: opts.false_label }
                        : { t: '✓', f: '—' };
                    return value ? labels.t : labels.f;
                }
                // Relation - link to related object
                if (dt === 'relation' && cls && value) {
                    return `<a href="#" onclick="viewObject('${cls}','${value}');return false">${esc(value)}</a>`;
                }
                // Array - show count
                if (prop.is_array) return `[${Array.isArray(value) ? value.length : 0}]`;
                // Object - show indicator
                if (dt === 'object') return value ? '{...}' : '—';
                // Default: string representation
                return esc(String(value ?? ''));
            },

            /** Render a single editor row (ge-key + ge-val cells) */
            renderRow(label, req, metaBtn, typeLabel, content) {
                return `<tr>
                    <td class="ge-key">${esc(label)} ${req}${metaBtn}<span class="t">${typeLabel}</span><div class="ge-resizer" onmousedown="geStartResize(event, this)"></div></td>
                    <td class="ge-val">${content}</td>
                </tr>`;
            },

            /** Render nested content row (for arrays/objects) */
            renderNestRow(lvl, foldId, content) {
                return `<tr class="ge-nest-row">
                    <td class="ge-nest-indent l${Math.min(lvl + 1, 3)}">
                        <button type="button" class="ge-fold" onclick="elementStore.fold(this)" data-target="${foldId}" title="Collapse/Expand">−</button>
                    </td>
                    <td class="ge-nest-content" id="${foldId}">${content}</td>
                </tr>`;
            },

            /** Render props table for object (used by geObject and geArrayItem) */
            async getPropsTable(meta, obj, path, lvl, cls) {
                const sorted = this.getSortedProps(meta);
                let html = `<table class="ge" data-path="${path}" data-class="${cls || ''}"><tbody>`;
                for (const p of sorted) {
                    html += await geField(p, obj[p.key], `${path}.${p.key}`, lvl + 1);
                }
                html += `</tbody></table>`;
                return html;
            },

            /** Unified fold toggle - works for nest-row and array items */
            fold(btn) {
                // Check if it's a data-target based fold (nest-row)
                const targetId = btn.dataset.target;
                if (targetId) {
                    const content = document.getElementById(targetId);
                    if (!content) return;
                    const isCollapsed = content.classList.toggle('collapsed');
                    btn.classList.toggle('collapsed', isCollapsed);
                    btn.textContent = isCollapsed ? '+' : '−';
                    return;
                }
                // Otherwise it's an array item fold
                const item = btn.closest('.ge-arr-item');
                if (!item) return;
                const isCollapsed = item.classList.toggle('collapsed');
                btn.classList.toggle('collapsed', isCollapsed);
                btn.textContent = isCollapsed ? '+' : '−';
            },

            // =========================================================================
            // COLLECTION RENDERING - For Objects tab (tables with multiple elements)
            // =========================================================================

            /** Render table headers from props */
            renderTableHeaders(props) {
                let html = '<tr>';
                for (const prop of props) {
                    html += this.propToHeader(prop);
                }
                html += '<th class="actions">Actions</th></tr>';
                return html;
            },

            /** Render table row for a single object */
            renderTableRow(props, obj, onEdit) {
                let html = `<tr data-id="${esc(obj.id || '')}">`;
                for (const prop of props) {
                    html += `<td>${this.propToCell(prop, obj[prop.key], obj.id)}</td>`;
                }
                const editFn = onEdit ? `onclick="${onEdit}('${esc(obj.id)}')"` : '';
                html += `<td class="actions">
                    <button class="btn btn-sm" ${editFn}>Edit</button>
                </td></tr>`;
                return html;
            },

            /** Render complete objects table */
            async renderObjectsTable(classId, objects, onEdit) {
                const meta = await getClassMeta(classId);
                if (!meta) return `<div class="form-hint">Class "${classId}" not found</div>`;

                const props = this.getSortedProps(meta);
                let html = '<table class="obj-table"><thead>';
                html += this.renderTableHeaders(props);
                html += '</thead><tbody>';

                for (const obj of objects) {
                    html += this.renderTableRow(props, obj, onEdit);
                }

                if (objects.length === 0) {
                    html += `<tr><td colspan="${props.length + 1}" class="empty">No objects</td></tr>`;
                }

                html += '</tbody></table>';
                return html;
            },

            /** Collect data from editor container (type-aware) */
            collectData(container) {
                const data = {};
                container.querySelectorAll('[data-path]').forEach(el => {
                    const path = el.dataset.path;
                    const type = el.dataset.type;
                    let val;

                    switch (type) {
                        case 'boolean':
                            val = el.checked;
                            break;
                        case 'integer':
                        case 'number':
                            val = el.value ? parseInt(el.value, 10) : null;
                            break;
                        case 'float':
                            val = el.value ? parseFloat(el.value) : null;
                            break;
                        case 'json':
                        case 'object':
                            try { val = JSON.parse(el.value || '{}'); } catch { val = el.value; }
                            break;
                        case 'relation':
                            val = el.value || null;
                            break;
                        case 'enum':
                            // Handle combo box with custom value
                            if (el.value === '__custom__' && el.dataset.customValue) {
                                val = el.dataset.customValue;
                            } else {
                                val = el.value || null;
                            }
                            break;
                        default:
                            val = el.value;
                    }

                    setNestedValue(data, path, val);
                });
                return data;
            },

            /**
             * Render unique constraints editor
             * Format: [{ id: "unique_id", fields: ["field1", "'-'", "field2"] }]
             * @param {Array} constraints - Array of unique constraint objects
             * @param {string} path - Data path
             * @param {Array} availableProps - Props available for selection
             * @returns {string} HTML
             */
            renderUniqueEditor(constraints, path, availableProps) {
                const arr = Array.isArray(constraints) ? constraints : [];
                const propOptions = availableProps.map(p => `<option value="${esc(p.key)}">${esc(p.label || p.key)}</option>`).join('');

                let html = `<div class="ge-unique" data-path="${path}">
                    <div class="ge-unique-list">`;

                arr.forEach((constraint, idx) => {
                    const cid = constraint.id || '';
                    const fields = Array.isArray(constraint.fields) ? constraint.fields : [];
                    html += `<div class="ge-unique-item" data-idx="${idx}">
                        <div class="ge-unique-item-hdr">
                            <input type="text" class="ge-unique-id" value="${esc(cid)}" placeholder="Constraint ID (e.g., unique_email)">
                            <button type="button" class="ge-btn ge-btn-del" onclick="elementStore.removeUniqueConstraint(this)">Delete</button>
                        </div>
                        <div class="ge-unique-fields">
                            ${fields.map((f, fi) => this.renderUniqueFieldItem(f, fi, propOptions)).join('')}
                            <button type="button" class="ge-btn ge-btn-add" onclick="elementStore.addUniqueField(this, \`${propOptions.replace(/`/g, '\\`')}\`)">+ Field</button>
                        </div>
                    </div>`;
                });

                if (arr.length === 0) {
                    html += `<div class="ge-unique-empty">No unique constraints. ID field is unique by default.</div>`;
                }

                html += `</div>
                    <button type="button" class="ge-btn ge-btn-add" onclick="elementStore.addUniqueConstraint(this, \`${propOptions.replace(/`/g, '\\`')}\`)">+ Add Constraint</button>
                </div>`;
                return html;
            },

            /** Render single field item in unique constraint */
            renderUniqueFieldItem(field, idx, propOptions) {
                const isConstant = field.startsWith("'") && field.endsWith("'");
                const value = isConstant ? field.slice(1, -1) : field;
                return `<div class="ge-unique-field" data-idx="${idx}">
                    <select class="ge-unique-field-type" onchange="elementStore.toggleUniqueFieldType(this)">
                        <option value="field" ${!isConstant ? 'selected' : ''}>Field</option>
                        <option value="constant" ${isConstant ? 'selected' : ''}>Constant</option>
                    </select>
                    ${isConstant
                        ? `<input type="text" class="ge-unique-field-val" value="${esc(value)}" placeholder="e.g., -">`
                        : `<select class="ge-unique-field-val"><option value="">--</option>${propOptions.replace(`value="${value}"`, `value="${value}" selected`)}</select>`
                    }
                    <button type="button" class="ge-btn-sm ge-btn-del" onclick="this.parentElement.remove()">×</button>
                </div>`;
            },

            /** Add new unique constraint */
            addUniqueConstraint(btn, propOptions) {
                const list = btn.previousElementSibling;
                const empty = list.querySelector('.ge-unique-empty');
                if (empty) empty.remove();

                const idx = list.querySelectorAll('.ge-unique-item').length;
                const html = `<div class="ge-unique-item" data-idx="${idx}">
                    <div class="ge-unique-item-hdr">
                        <input type="text" class="ge-unique-id" value="" placeholder="Constraint ID (e.g., unique_email)">
                        <button type="button" class="ge-btn ge-btn-del" onclick="elementStore.removeUniqueConstraint(this)">Delete</button>
                    </div>
                    <div class="ge-unique-fields">
                        <button type="button" class="ge-btn ge-btn-add" onclick="elementStore.addUniqueField(this, \`${propOptions}\`)">+ Field</button>
                    </div>
                </div>`;
                list.insertAdjacentHTML('beforeend', html);
            },

            /** Remove unique constraint */
            removeUniqueConstraint(btn) {
                const item = btn.closest('.ge-unique-item');
                const list = item.parentElement;
                item.remove();
                if (list.querySelectorAll('.ge-unique-item').length === 0) {
                    list.innerHTML = '<div class="ge-unique-empty">No unique constraints. ID field is unique by default.</div>';
                }
            },

            /** Add field to unique constraint */
            addUniqueField(btn, propOptions) {
                const fieldsContainer = btn.parentElement;
                const idx = fieldsContainer.querySelectorAll('.ge-unique-field').length;
                const html = `<div class="ge-unique-field" data-idx="${idx}">
                    <select class="ge-unique-field-type" onchange="elementStore.toggleUniqueFieldType(this)">
                        <option value="field" selected>Field</option>
                        <option value="constant">Constant</option>
                    </select>
                    <select class="ge-unique-field-val"><option value="">--</option>${propOptions}</select>
                    <button type="button" class="ge-btn-sm ge-btn-del" onclick="this.parentElement.remove()">×</button>
                </div>`;
                btn.insertAdjacentHTML('beforebegin', html);
            },

            /** Toggle between field select and constant input */
            toggleUniqueFieldType(select) {
                const container = select.parentElement;
                const valEl = container.querySelector('.ge-unique-field-val');
                const isConstant = select.value === 'constant';

                if (isConstant && valEl.tagName === 'SELECT') {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'ge-unique-field-val';
                    input.placeholder = "e.g., -";
                    valEl.replaceWith(input);
                } else if (!isConstant && valEl.tagName === 'INPUT') {
                    // Need propOptions - get from parent
                    const addBtn = container.parentElement.querySelector('.ge-btn-add');
                    const propOptions = addBtn?.onclick?.toString().match(/`([^`]*)`/)?.[1] || '';
                    const sel = document.createElement('select');
                    sel.className = 'ge-unique-field-val';
                    sel.innerHTML = `<option value="">--</option>${propOptions}`;
                    valEl.replaceWith(sel);
                }
            },

            /** Collect unique constraints from editor */
            collectUniqueConstraints(container) {
                const uniqueEl = container.querySelector('.ge-unique');
                if (!uniqueEl) return undefined;

                const constraints = [];
                uniqueEl.querySelectorAll('.ge-unique-item').forEach(item => {
                    const id = item.querySelector('.ge-unique-id')?.value?.trim();
                    if (!id) return;

                    const fields = [];
                    item.querySelectorAll('.ge-unique-field').forEach(fieldEl => {
                        const type = fieldEl.querySelector('.ge-unique-field-type')?.value;
                        const val = fieldEl.querySelector('.ge-unique-field-val')?.value?.trim();
                        if (!val) return;
                        fields.push(type === 'constant' ? `'${val}'` : val);
                    });

                    if (fields.length > 0) {
                        constraints.push({ id, fields });
                    }
                });

                return constraints.length > 0 ? constraints : undefined;
            },

            /**
             * Render complete editor for a class (main entry point)
             * @param {string} classId - Class ID
             * @param {object} data - Object data to edit
             * @returns {Promise<string>} HTML
             */
            async renderEditor(classId, data) {
                const meta = await getClassMeta(classId);
                if (!meta) return `<div class="form-hint">Class "${classId}" not found</div>`;

                const sorted = this.getSortedProps(meta);

                let html = `<table class="ge"><tbody>`;
                // ID field first (if not already in props)
                if (!sorted.find(p => p.key === 'id')) {
                    html += `<tr>
                        <td class="ge-key">id <span class="t">string</span></td>
                        <td class="ge-val"><input type="text" data-path="id" value="${esc(data?.id || '')}" ${data?.id ? 'readonly' : ''} placeholder="Auto-generated"></td>
                    </tr>`;
                }
                for (const prop of sorted) {
                    html += await geField(prop, data?.[prop.key], prop.key, 0);
                }
                html += `</tbody></table>`;
                return html;
            }
        };

        // =====================================================================
        // GENERIC EDITOR FIELD RENDERING
        // =====================================================================

        /**
         * Render a single field (recursive)
         * @param {object} prop - Property definition
         * @param {any} value - Current value
         * @param {string} path - Data path (e.g., "address.city" or "items[0].name")
         * @param {number} lvl - Nesting level (0-3)
         */
        async function geField(prop, value, path, lvl) {
            const dt = prop.data_type || 'string';
            const isArr = prop.is_array;
            const cls = elementStore.getCls(prop);
            const label = elementStore.getPropLabel(prop);
            const typeLabel = elementStore.getPropType(prop);
            const req = prop.required ? '<span class="req">*</span>' : '';
            const propJson = esc(JSON.stringify(prop));
            const metaBtn = `<button type="button" class="ge-meta-btn" onclick="showPropMeta(this)" data-prop="${propJson}" title="View @prop meta">@</button>`;
            const foldId = elementStore.getFoldId(path);

            let html = '';

            if (isArr) {
                // Array field - header row + nested content row
                const arr = Array.isArray(value) ? value : [];
                const content = `<span class="ge-arr-inline">
                    <span class="count">${arr.length}</span>
                    <button type="button" class="ge-btn ge-btn-add" onclick="geAddItem('${path}')">+ Add</button>
                </span>`;
                html += elementStore.renderRow(label, req, metaBtn, typeLabel, content);
                html += elementStore.renderNestRow(lvl, foldId, await geArray(prop, value, path, lvl));
            } else if (dt === 'object' && cls) {
                // Nested object - header row + nested content row
                const content = `<span class="ge-obj-inline"><span class="cls">${cls}</span></span>`;
                html += elementStore.renderRow(label, req, metaBtn, typeLabel, content);
                html += elementStore.renderNestRow(lvl, foldId, await geObject(prop, value, path, lvl, cls));
            } else if (dt === 'relation') {
                // Relation - simple row with dropdown
                html += elementStore.renderRow(label, req, metaBtn, typeLabel, await geRelation(prop, value, path));
            } else {
                // Simple field
                html += elementStore.renderRow(label, req, metaBtn, typeLabel, geInput(prop, value, path));
            }
            return html;
        }

        // Show @prop meta in popup
        function showPropMeta(btn) {
            const prop = JSON.parse(btn.dataset.prop);
            const content = JSON.stringify(prop, null, 2);
            alert('@prop meta:\n\n' + content);
        }

        /**
         * Render simple input based on data_type and prop.options
         * Options by data_type:
         * - string: values[], allow_custom, min_length, max_length, pattern
         * - integer/float: min, max, step, values[]
         * - boolean: true_label, false_label
         * - unique: generator (uuid|auto_increment|custom), prefix
         */
        function geInput(prop, value, path) {
            const dt = prop.data_type || 'string';
            const opts = prop.options || {};
            const v = value ?? prop.default_value ?? '';
            const safeVal = esc(typeof v === 'object' ? JSON.stringify(v) : String(v));
            const ph = esc(prop.description || '');

            // Boolean with optional custom labels
            if (dt === 'boolean') {
                const checked = v === true || v === 'true' ? 'checked' : '';
                const label = checked ? (opts.true_label || 'Yes') : (opts.false_label || 'No');
                return `<label class="ge-toggle">
                    <input type="checkbox" data-path="${path}" data-type="boolean" ${checked}>
                    <span class="ge-toggle-label">${esc(label)}</span>
                </label>`;
            }

            // Enum/select (string with values[])
            if (prop.enum_values?.length || opts.values?.length) {
                const values = prop.enum_values || opts.values || [];
                const allowCustom = opts.allow_custom || prop.enum_allow_custom;
                const optHtml = values.map(o => `<option value="${esc(o)}" ${v === o ? 'selected' : ''}>${esc(o)}</option>`).join('');

                if (allowCustom) {
                    // Combo: select + text input for custom value
                    const isCustom = v && !values.includes(v);
                    return `<div class="ge-combo">
                        <select data-path="${path}" data-type="enum" onchange="geComboChange(this)">
                            <option value="">--</option>
                            ${optHtml}
                            <option value="__custom__" ${isCustom ? 'selected' : ''}>Custom...</option>
                        </select>
                        <input type="text" class="ge-combo-custom" value="${isCustom ? safeVal : ''}"
                               style="display:${isCustom ? 'block' : 'none'}" placeholder="Enter custom value"
                               onchange="geComboCustomChange(this, '${path}')">
                    </div>`;
                }
                return `<select data-path="${path}" data-type="enum"><option value="">--</option>${optHtml}</select>`;
            }

            // Number types with min/max/step
            if (dt === 'integer' || dt === 'number') {
                const min = opts.min !== undefined ? `min="${opts.min}"` : '';
                const max = opts.max !== undefined ? `max="${opts.max}"` : '';
                const step = opts.step !== undefined ? `step="${opts.step}"` : 'step="1"';
                return `<input type="number" data-path="${path}" data-type="${dt}" value="${safeVal}" ${min} ${max} ${step} placeholder="${ph}">`;
            }
            if (dt === 'float') {
                const min = opts.min !== undefined ? `min="${opts.min}"` : '';
                const max = opts.max !== undefined ? `max="${opts.max}"` : '';
                const step = opts.step !== undefined ? `step="${opts.step}"` : 'step="any"';
                return `<input type="number" data-path="${path}" data-type="float" value="${safeVal}" ${min} ${max} ${step} placeholder="${ph}">`;
            }

            // Function/code
            if (dt === 'function') {
                return `<textarea class="code" data-path="${path}" data-type="function" placeholder="function(scope) { ... }">${safeVal}</textarea>`;
            }

            // Generic object (JSON)
            if (dt === 'object') {
                const jsonVal = typeof v === 'object' ? JSON.stringify(v, null, 2) : v;
                return `<textarea class="code" data-path="${path}" data-type="json" placeholder="{ }">${esc(jsonVal)}</textarea>`;
            }

            // Date/datetime
            if (dt === 'date') return `<input type="date" data-path="${path}" data-type="date" value="${safeVal}">`;
            if (dt === 'datetime') return `<input type="datetime-local" data-path="${path}" data-type="datetime" value="${safeVal}">`;

            // Textarea for description/long text
            if (prop.editor === 'textarea' || prop.key === 'description') {
                return `<textarea data-path="${path}" data-type="string" placeholder="${ph}">${safeVal}</textarea>`;
            }

            // String with pattern validation
            if (opts.pattern) {
                return `<input type="text" data-path="${path}" data-type="${dt}" value="${safeVal}" pattern="${esc(opts.pattern)}" placeholder="${ph}">`;
            }

            // String with length constraints
            const minLen = opts.min_length !== undefined ? `minlength="${opts.min_length}"` : '';
            const maxLen = opts.max_length !== undefined ? `maxlength="${opts.max_length}"` : '';

            // Default: text input
            return `<input type="text" data-path="${path}" data-type="${dt}" value="${safeVal}" ${minLen} ${maxLen} placeholder="${ph}">`;
        }

        // Helper for combo box (select with custom option)
        function geComboChange(select) {
            const customInput = select.nextElementSibling;
            if (select.value === '__custom__') {
                customInput.style.display = 'block';
                customInput.focus();
            } else {
                customInput.style.display = 'none';
                customInput.value = '';
            }
        }

        function geComboCustomChange(input, path) {
            // Update a hidden input or the select's data attribute
            const select = input.previousElementSibling;
            select.dataset.customValue = input.value;
        }

        /**
         * Render relation field (dropdown with objects from related class)
         */
        async function geRelation(prop, value, path) {
            const cls = elementStore.getCls(prop);
            const v = value || '';

            // No class specified - just text input
            if (!cls) {
                return `<input type="text" data-path="${path}" data-type="relation" value="${esc(v)}" placeholder="ID">`;
            }

            // Load objects from related class
            let objects = [];
            try {
                if (cls === '@class') {
                    objects = allClassesList || [];
                } else {
                    objects = await api('GET', `/store/${cls}`) || [];
                }
            } catch (e) {
                console.warn(`Could not load ${cls} objects:`, e);
            }

            // Build dropdown
            const opts = objects.map(o => {
                const id = o.id;
                const label = o.name || o.label || o.key || id;
                const selected = v === id ? 'selected' : '';
                return `<option value="${esc(id)}" ${selected}>${esc(id)}${label !== id ? ` (${esc(label)})` : ''}</option>`;
            }).join('');

            return `<div class="ge-rel">
                <select data-path="${path}" data-type="relation" data-class="${cls}">
                    <option value="">-- Select ${cls} --</option>
                    ${opts}
                </select>
                <span class="ge-rel-info">${objects.length} available</span>
            </div>`;
        }

        /**
         * Render nested object (just the table, no wrapper - header is in parent row)
         */
        async function geObject(prop, value, path, lvl, cls) {
            const obj = typeof value === 'object' && value !== null ? value : {};
            const meta = await getClassMeta(cls);

            if (!meta) {
                // Fallback to JSON editor
                const jsonVal = JSON.stringify(obj, null, 2);
                return `<textarea class="code" data-path="${path}" data-type="json" style="width:100%">${esc(jsonVal)}</textarea>`;
            }

            return await elementStore.getPropsTable(meta, obj, path, lvl, cls);
        }

        /**
         * Render array items (no header - header is in parent row)
         */
        async function geArray(prop, value, path, lvl) {
            const arr = Array.isArray(value) ? value : [];
            const dt = prop.data_type || 'string';
            const cls = elementStore.getCls(prop);
            const isNestedObjArr = dt === 'object' && cls;
            const isRelationArr = dt === 'relation';

            let html = `<div class="ge-arr" data-path="${path}" data-type="${dt}" data-class="${cls || ''}">`;
            for (let i = 0; i < arr.length; i++) {
                html += await geArrayItem(prop, arr[i], `${path}[${i}]`, i, lvl, isNestedObjArr, isRelationArr, cls);
            }
            if (arr.length === 0) {
                html += `<div style="padding:8px;color:#9ca3af;font-size:12px;font-style:italic">No items</div>`;
            }
            html += `</div>`;
            return html;
        }

        /**
         * Render single array item
         */
        async function geArrayItem(prop, value, path, idx, lvl, isNestedObjArr, isRelationArr, cls) {
            const hasNested = isNestedObjArr && cls;
            let html = `<div class="ge-arr-item" data-idx="${idx}">
                <div class="ge-arr-item-hdr">
                    <span class="left">
                        ${hasNested ? `<button type="button" class="ge-fold" onclick="elementStore.fold(this)" title="Collapse/Expand">−</button>` : ''}
                        <span class="idx">[${idx}]</span>
                    </span>
                    <button type="button" class="ge-btn ge-btn-del" onclick="geDelItem(this)">Delete</button>
                </div>
                <div class="ge-arr-item-body">`;

            if (isNestedObjArr && cls) {
                // Array of embedded objects with class
                const obj = typeof value === 'object' && value !== null ? value : {};
                const meta = await getClassMeta(cls);
                if (meta) {
                    html += await elementStore.getPropsTable(meta, obj, path, lvl, cls);
                } else {
                    html += `<textarea class="code" data-path="${path}" data-type="json">${esc(JSON.stringify(obj, null, 2))}</textarea>`;
                }
            } else if (isRelationArr) {
                // Array of relation IDs - show dropdown
                html += await geRelation({...prop, is_array: false}, value, path);
            } else {
                // Simple array items
                html += geInput({...prop, is_array: false}, value, path);
            }
            html += `</div></div>`;
            return html;
        }

        // Helper: escape HTML
        function esc(s) { return String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

        // Note: geFold is now defined above as a unified helper function

        // Column resizing for GE tables
        let geResizing = null;
        let geResizeStartX = 0;
        let geResizeStartWidth = 0;

        function geStartResize(e, resizer) {
            e.preventDefault();
            const cell = resizer.parentElement;
            const table = cell.closest('.ge');
            geResizing = { table, cell };
            geResizeStartX = e.pageX;
            geResizeStartWidth = cell.offsetWidth;
            resizer.classList.add('active');
            document.addEventListener('mousemove', geDoResize);
            document.addEventListener('mouseup', geStopResize);
        }

        function geDoResize(e) {
            if (!geResizing) return;
            const diff = e.pageX - geResizeStartX;
            const newWidth = Math.max(80, Math.min(400, geResizeStartWidth + diff));
            // Apply width to all ge-key cells in this table
            geResizing.table.querySelectorAll(':scope > tbody > tr > .ge-key').forEach(cell => {
                cell.style.width = newWidth + 'px';
            });
        }

        function geStopResize() {
            if (!geResizing) return;
            geResizing.table.querySelectorAll('.ge-resizer.active').forEach(r => r.classList.remove('active'));
            geResizing = null;
            document.removeEventListener('mousemove', geDoResize);
            document.removeEventListener('mouseup', geStopResize);
        }

        // Add array item
        async function geAddItem(path) {
            const container = document.querySelector(`[data-path="${path}"].ge-arr`);
            if (!container) return;
            const dt = container.dataset.type;
            const cls = container.dataset.class;
            const items = container.querySelectorAll('.ge-arr-item');
            const idx = items.length;
            const newPath = `${path}[${idx}]`;

            // Remove "No items" message if present
            const emptyMsg = container.querySelector('div[style*="italic"]');
            if (emptyMsg) emptyMsg.remove();

            // Create empty prop for item
            const itemProp = { data_type: dt, object_class_id: cls || null };
            const isNestedObjArr = dt === 'object' && cls;
            const isRelationArr = dt === 'relation';
            const defaultVal = isNestedObjArr ? {} : (dt === 'boolean' ? false : '');

            const html = await geArrayItem(itemProp, defaultVal, newPath, idx, 0, isNestedObjArr, isRelationArr, cls);
            container.insertAdjacentHTML('beforeend', html);

            // Update count in parent row
            const countSpan = document.querySelector(`button[onclick="geAddItem('${path}')"]`)?.parentElement?.querySelector('.count');
            if (countSpan) countSpan.textContent = idx + 1;
        }

        // Delete array item
        function geDelItem(btn) {
            const item = btn.closest('.ge-arr-item');
            const container = item.closest('.ge-arr');
            const path = container.dataset.path;
            item.remove();

            // Reindex remaining items
            const items = container.querySelectorAll('.ge-arr-item');
            items.forEach((el, i) => {
                el.dataset.idx = i;
                el.querySelector('.idx').textContent = `[${i}]`;
                // Update all data-path within
                el.querySelectorAll('[data-path]').forEach(input => {
                    input.dataset.path = input.dataset.path.replace(/\[\d+\]/, `[${i}]`);
                });
            });

            // Update count in parent row
            const countSpan = document.querySelector(`button[onclick="geAddItem('${path}')"]`)?.parentElement?.querySelector('.count');
            if (countSpan) countSpan.textContent = items.length;

            // Show "No items" if empty
            if (items.length === 0) {
                container.innerHTML = `<div style="padding:8px;color:#9ca3af;font-size:12px;font-style:italic">No items</div>`;
            }
        }

        // Browse relation
        async function geBrowse(path, classId) {
            try {
                const objects = await api('GET', `/store/${classId}`);
                if (!objects?.length) { showToast(`No ${classId} objects found`, 'error'); return; }
                const options = objects.map(o => `${o.id} - ${o.name || o.id}`).join('\n');
                const selected = prompt(`Select ${classId}:\n\nAvailable:\n${options}`);
                if (selected) {
                    const id = selected.split(' - ')[0].trim();
                    const input = document.querySelector(`[data-path="${path}"]`);
                    if (input) input.value = id;
                }
            } catch (err) { showToast(err.message, 'error'); }
        }

        // Collect data from generic editor (delegates to elementStore)
        function geCollectData(container) {
            return elementStore.collectData(container);
        }

        // Set value at nested path
        function setNestedValue(obj, path, val) {
            const parts = path.replace(/\[(\d+)\]/g, '.$1').split('.');
            let curr = obj;
            for (let i = 0; i < parts.length - 1; i++) {
                const key = parts[i];
                const nextKey = parts[i + 1];
                const isNextArray = /^\d+$/.test(nextKey);
                if (!(key in curr)) curr[key] = isNextArray ? [] : {};
                curr = curr[key];
            }
            const lastKey = parts[parts.length - 1];
            if (val !== null && val !== '' && val !== undefined) {
                curr[lastKey] = val;
            }
        }

        // =====================
        // Render Property Editor (uses Generic Editor)
        // =====================
        async function renderPropertyEditor() {
            const meta = await getClassMeta(editingClassId);
            const data = editingObject || {};

            // Store props for validation lookup
            currentFormProps = {};
            const props = meta?.props || [];
            const propsArray = Array.isArray(props) ? props : Object.values(props);
            propsArray.forEach(p => currentFormProps[p.key] = p);

            // Use generic editor
            const editorHtml = await renderGenericEditor(editingClassId, data);

            let html = `
                <div style="margin-bottom:12px;padding:8px 12px;background:#f0f4ff;border-radius:6px;font-size:12px">
                    <strong>${editingClassId}</strong>
                    <span style="color:#6366f1;margin-left:8px">${propsArray.length} properties</span>
                    <button type="button" class="btn-json-toggle" onclick="toggleMetaViewer()" style="float:right">{ } Schema</button>
                </div>
                <div id="metaViewerContent" style="display:none;margin-bottom:12px;padding:12px;background:#1e1e1e;border-radius:6px;max-height:200px;overflow:auto">
                    <pre style="margin:0;font-size:11px;color:#9cdcfe;white-space:pre-wrap">${esc(JSON.stringify(meta, null, 2))}</pre>
                </div>
                <div id="geContainer">${editorHtml}</div>
            `;

            if (data.created_at || data.updated_at || data.owner_id) {
                html += `<div style="margin-top:12px;padding:8px 12px;background:#f9fafb;border-radius:4px;font-size:11px;color:#6b7280">
                    ${data.owner_id ? `Owner: ${data.owner_id} | ` : ''}
                    ${data.created_at ? `Created: ${data.created_at} | ` : ''}
                    ${data.updated_at ? `Updated: ${data.updated_at}` : ''}
                </div>`;
            }

            document.getElementById('modalBody').innerHTML = html;
        }

        // Toggle meta viewer
        function toggleMetaViewer() {
            const el = document.getElementById('metaViewerContent');
            if (el) el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }

        // Toggle property group (legacy support)
        function togglePropGroup(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.group-icon');
            if (content?.style) {
                content.style.display = content.style.display === 'none' ? '' : 'none';
                if (icon) icon.textContent = content.style.display === 'none' ? '▶' : '▼';
            }
        }

        // =====================
        // Special @prop Class Editor (LEGACY - now uses generic editor)
        // Kept for reference but not used
        // =====================
        async function renderPropClassEditorLegacy() {
            const data = editingObject || {};
            const currentDataType = data.data_type || 'string';

            // All classes for object_class_id selection
            const classes = allClassesList || [];
            const classOptions = classes.map(c => ({ id: c.id, name: c.name }));

            // Editor options from @editor
            const editorOptions = Object.entries(editorConfig.editors || {}).map(([id, e]) => ({
                id,
                name: e.name,
                data_types: e.data_types || []
            }));

            // Filter editors by current data type
            const compatibleEditors = editorOptions.filter(e =>
                e.data_types.includes(currentDataType)
            );

            let html = `
                <div class="prop-editor">
                    <div class="prop-editor-header">
                        <span>Property Definition <span style="background:#667eea;color:#fff;padding:2px 8px;border-radius:3px;font-size:10px;margin-left:6px">@prop</span></span>
                    </div>
                    <div class="prop-editor-body">
                        <table class="prop-table">
                            <tbody>
                                <!-- DATA TYPE - FIRST! Drives conditional fields -->
                                <tr>
                                    <td class="prop-name">data_type <span class="prop-required">*</span> <span class="type-badge">enum</span></td>
                                    <td class="prop-edit">
                                        <select class="form-select" data-prop="data_type" data-type="enum" onchange="updatePropConditionalFields()">
                                            ${DATA_TYPES.map(dt => `<option value="${dt}" ${currentDataType === dt ? 'selected' : ''}>${dt}</option>`).join('')}
                                        </select>
                                    </td>
                                </tr>

                                <!-- IS ARRAY - Any type can be array -->
                                <tr>
                                    <td class="prop-name">is_array <span class="type-badge">boolean</span></td>
                                    <td class="prop-edit">
                                        <label class="toggle-switch">
                                            <input type="checkbox" data-prop="is_array" data-type="boolean" ${data.is_array ? 'checked' : ''}>
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <span style="margin-left:8px;font-size:11px;color:#6b7280">Property holds multiple values</span>
                                    </td>
                                </tr>

                                <!-- CORE GROUP: key, label, description -->
                                <tr class="prop-group-row">
                                    <td colspan="2" class="prop-group-header" onclick="togglePropGroup(this)">
                                        <span class="group-icon">▼</span> Core (3)
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">key <span class="prop-required">*</span> <span class="type-badge">string</span></td>
                                    <td class="prop-edit">
                                        <input type="text" class="form-input" data-prop="key" data-type="string" value="${data.key || ''}" placeholder="field_name" required>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">label <span class="type-badge">string</span></td>
                                    <td class="prop-edit">
                                        <input type="text" class="form-input" data-prop="label" data-type="string" value="${data.label || ''}" placeholder="Display Label">
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">description <span class="type-badge">string</span></td>
                                    <td class="prop-edit">
                                        <textarea class="form-textarea" data-prop="description" data-type="string" rows="2" placeholder="Help text for users">${data.description || ''}</textarea>
                                    </td>
                                </tr>

                                <!-- OPTIONS GROUP: Type-specific options (conditional) -->
                                <tr class="prop-group-row">
                                    <td colspan="2" class="prop-group-header" onclick="togglePropGroup(this)">
                                        <span class="group-icon">▼</span> Type Options
                                    </td>
                                </tr>
                                <tr>
                                    <td colspan="2" class="prop-nested">
                                        <div id="prop_options_container">
                                            ${renderOptionsEditor(currentDataType, data.options, 'prop')}
                                        </div>
                                    </td>
                                </tr>

                                <!-- RELATION GROUP: object_class_id, on_orphan, object_class_strict (conditional - only for object/relation) -->
                                <tr class="prop-group-row conditional-group" id="relation_group" style="${RELATION_TYPES.includes(currentDataType) ? '' : 'display:none'}">
                                    <td colspan="2" class="prop-group-header" onclick="togglePropGroup(this)">
                                        <span class="group-icon">▼</span> Relation Settings (3)
                                    </td>
                                </tr>
                                <tr class="conditional-group" id="relation_class_row" style="${RELATION_TYPES.includes(currentDataType) ? '' : 'display:none'}">
                                    <td class="prop-name">object_class_id <span class="type-badge">string[]</span></td>
                                    <td class="prop-edit">
                                        ${renderTagSelect(classOptions, data.object_class_id, 'prop_class_ids', {
                                            maxTags: 0,
                                            searchable: true,
                                            placeholder: 'Select target classes...',
                                            dataAttr: 'data-prop="object_class_id"'
                                        })}
                                    </td>
                                </tr>
                                <tr class="conditional-group" id="relation_strict_row" style="${RELATION_TYPES.includes(currentDataType) ? '' : 'display:none'}">
                                    <td class="prop-name">object_class_strict <span class="type-badge">boolean</span></td>
                                    <td class="prop-edit">
                                        <label class="toggle-switch">
                                            <input type="checkbox" data-prop="object_class_strict" data-type="boolean" ${data.object_class_strict ? 'checked' : ''}>
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <span style="margin-left:8px;font-size:11px;color:#6b7280">Only accept exact class, not children</span>
                                    </td>
                                </tr>
                                <tr class="conditional-group" id="relation_orphan_row" style="${RELATION_TYPES.includes(currentDataType) ? '' : 'display:none'}">
                                    <td class="prop-name">on_orphan <span class="type-badge">enum</span></td>
                                    <td class="prop-edit">
                                        <select class="form-select" data-prop="on_orphan" data-type="enum">
                                            <option value="keep" ${(data.on_orphan || 'keep') === 'keep' ? 'selected' : ''}>keep - Keep orphaned objects</option>
                                            <option value="delete" ${data.on_orphan === 'delete' ? 'selected' : ''}>delete - Delete when no references</option>
                                            <option value="nullify" ${data.on_orphan === 'nullify' ? 'selected' : ''}>nullify - Set reference to null</option>
                                        </select>
                                    </td>
                                </tr>

                                <!-- UI GROUP: editor, display_order, group_name, hidden -->
                                <tr class="prop-group-row">
                                    <td colspan="2" class="prop-group-header" onclick="togglePropGroup(this)">
                                        <span class="group-icon">▼</span> UI Configuration (4)
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">editor <span class="type-badge">@editor</span></td>
                                    <td class="prop-edit">
                                        <select class="form-select" data-prop="editor" data-type="relation" id="prop_editor_select">
                                            <option value="">-- Auto (default for type) --</option>
                                            ${compatibleEditors.map(e => {
                                                const isSelected = (data.editor?.type || data.editor) === e.id;
                                                return `<option value="${e.id}" ${isSelected ? 'selected' : ''}>${e.id} - ${e.name}</option>`;
                                            }).join('')}
                                        </select>
                                        <div class="form-hint">Editors compatible with ${currentDataType}</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">display_order <span class="type-badge">integer</span></td>
                                    <td class="prop-edit">
                                        <input type="number" class="form-input" data-prop="display_order" data-type="integer" value="${data.display_order || 0}" min="0">
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">group_name <span class="type-badge">string</span></td>
                                    <td class="prop-edit">
                                        <input type="text" class="form-input" data-prop="group_name" data-type="string" value="${data.group_name || ''}" placeholder="Form section name">
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">hidden <span class="type-badge">boolean</span></td>
                                    <td class="prop-edit">
                                        <label class="toggle-switch">
                                            <input type="checkbox" data-prop="hidden" data-type="boolean" ${data.hidden ? 'checked' : ''}>
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <span style="margin-left:8px;font-size:11px;color:#6b7280">Hide from default UI views</span>
                                    </td>
                                </tr>

                                <!-- VALIDATION GROUP: required, readonly, validators, default_value -->
                                <tr class="prop-group-row">
                                    <td colspan="2" class="prop-group-header" onclick="togglePropGroup(this)">
                                        <span class="group-icon">▼</span> Validation (4)
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">required <span class="type-badge">boolean</span></td>
                                    <td class="prop-edit">
                                        <label class="toggle-switch">
                                            <input type="checkbox" data-prop="required" data-type="boolean" ${data.required ? 'checked' : ''}>
                                            <span class="toggle-slider"></span>
                                        </label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">readonly <span class="type-badge">boolean</span></td>
                                    <td class="prop-edit">
                                        <label class="toggle-switch">
                                            <input type="checkbox" data-prop="readonly" data-type="boolean" ${data.readonly ? 'checked' : ''}>
                                            <span class="toggle-slider"></span>
                                        </label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">validators <span class="type-badge">@function[]</span></td>
                                    <td class="prop-edit">
                                        ${renderTagSelect(
                                            Object.entries(functionConfig.functions || {})
                                                .filter(([id, f]) => f.function_type === 'validator')
                                                .map(([id, f]) => ({ id, name: f.name })),
                                            data.validators || [],
                                            'prop_validators',
                                            {
                                                maxTags: 0,
                                                searchable: true,
                                                placeholder: 'Select validators...',
                                                dataAttr: 'data-prop="validators"'
                                            }
                                        )}
                                    </td>
                                </tr>
                                <tr>
                                    <td class="prop-name">default_value <span class="type-badge">${currentDataType}</span></td>
                                    <td class="prop-edit">
                                        <div id="prop_default_value_container">
                                            ${renderPropDefaultValueEditor(currentDataType, data.default_value)}
                                        </div>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            document.getElementById('modalBody').innerHTML = html;
        }

        // Render default_value editor based on data_type
        function renderPropDefaultValueEditor(dataType, value) {
            const safeValue = value !== undefined && value !== null ? String(value).replace(/"/g, '&quot;') : '';

            switch (dataType) {
                case 'boolean':
                    const checked = value === true || value === 'true';
                    return `
                        <label class="toggle-switch">
                            <input type="checkbox" data-prop="default_value" data-type="boolean" ${checked ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </label>
                    `;
                case 'integer':
                    return `<input type="number" class="form-input" data-prop="default_value" data-type="integer" value="${safeValue}" step="1">`;
                case 'float':
                    return `<input type="number" class="form-input" data-prop="default_value" data-type="float" value="${safeValue}" step="any">`;
                case 'object':
                    const jsonVal = value !== undefined && value !== null ?
                        (typeof value === 'object' ? JSON.stringify(value, null, 2) : safeValue) : '';
                    return `<textarea class="form-textarea json-editor" data-prop="default_value" data-type="json" rows="3" placeholder="{}">${jsonVal}</textarea>`;
                case 'function':
                    return `<textarea class="form-textarea code-editor" data-prop="default_value" data-type="function" rows="3" placeholder="// JavaScript code">${safeValue}</textarea>`;
                default:
                    return `<input type="text" class="form-input" data-prop="default_value" data-type="string" value="${safeValue}">`;
            }
        }

        // Update conditional fields when data_type changes
        function updatePropConditionalFields() {
            const dataTypeSelect = document.querySelector('[data-prop="data_type"]');
            if (!dataTypeSelect) return;

            const newDataType = dataTypeSelect.value;
            const isRelationType = RELATION_TYPES.includes(newDataType);

            // Show/hide relation fields
            document.querySelectorAll('#relation_group, #relation_class_row, #relation_strict_row, #relation_orphan_row').forEach(el => {
                el.style.display = isRelationType ? '' : 'none';
            });

            // Update options editor
            const optionsContainer = document.getElementById('prop_options_container');
            if (optionsContainer) {
                optionsContainer.innerHTML = renderOptionsEditor(newDataType, null, 'prop');
            }

            // Update default_value editor
            const defaultValueContainer = document.getElementById('prop_default_value_container');
            if (defaultValueContainer) {
                defaultValueContainer.innerHTML = renderPropDefaultValueEditor(newDataType, null);
            }

            // Update editor dropdown with compatible editors
            const editorSelect = document.getElementById('prop_editor_select');
            if (editorSelect) {
                const compatibleEditors = Object.entries(editorConfig.editors || {})
                    .filter(([id, e]) => (e.data_types || []).includes(newDataType))
                    .map(([id, e]) => ({ id, name: e.name }));

                const currentValue = editorSelect.value;
                editorSelect.innerHTML = `<option value="">-- Auto (default for type) --</option>` +
                    compatibleEditors.map(e => `<option value="${e.id}">${e.id} - ${e.name}</option>`).join('');

                // Try to keep current selection if still compatible
                if (compatibleEditors.some(e => e.id === currentValue)) {
                    editorSelect.value = currentValue;
                }

                const hint = editorSelect.nextElementSibling;
                if (hint) hint.textContent = `Editors compatible with ${newDataType}`;
            }
        }

        // Toggle property group expand/collapse
        function togglePropGroup(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.group-icon');
            if (content.style.display === 'none') {
                content.style.display = '';
                icon.textContent = '▼';
            } else {
                content.style.display = 'none';
                icon.textContent = '▶';
            }
        }

        // Escape HTML for attributes
        function escapeHtml(str) {
            return String(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        // =====================
        // Render Property Row
        // =====================
        async function renderPropertyRow(prop, value, nestLevel) {
            const key = prop.key;
            const label = prop.label || prop.name || key;
            const dataType = prop.data_type || 'string';
            const isRequired = prop.required;
            const isArray = prop.is_array;
            const relatedClass = prop.object_class_id;

            // Create safe JSON for display
            const propJson = JSON.stringify(prop, null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const propJsonOneLine = JSON.stringify(prop).replace(/"/g, '&quot;');

            let html = `<div class="prop-row">`;
            html += `<div class="prop-key">
                ${label}${isRequired ? '<span class="prop-required">*</span>' : ''}
                <span class="type-badge">${dataType}${isArray ? '[]' : ''}</span>
                <button type="button" class="btn-json-toggle" onclick="togglePropJson(this)" title="Show JSON definition">{ }</button>
            </div>`;
            html += `<div class="prop-value">
                <div class="prop-json-preview" style="display:none;">
                    <pre class="json-preview-code">${propJson}</pre>
                </div>`;

            if (isArray) {
                html += await renderArrayEditor(prop, value, nestLevel);
            } else if (dataType === 'object' && relatedClass) {
                html += await renderNestedObjectEditor(prop, value, nestLevel);
            } else if (dataType === 'relation') {
                html += await renderRelationEditor(prop, value);
            } else {
                html += renderSingleValueEditor(prop, value);
            }

            html += `</div></div>`;
            return html;
        }

        // =====================
        // Tag Select Component (Select2-like multi-select)
        // Used for object_class_id (multiple class selection) and other array string fields
        // =====================
        function renderTagSelect(options, selectedValues, containerId, config = {}) {
            const {
                maxTags = 0,        // 0 = unlimited
                searchable = true,
                allowCustom = false,
                placeholder = 'Select...',
                dataAttr = ''
            } = config;

            const selected = Array.isArray(selectedValues) ? selectedValues : (selectedValues ? [selectedValues] : []);

            const tagsHtml = selected.map(val => `
                <span class="tag" data-value="${val}">
                    ${val}
                    <span class="tag-remove" onclick="removeTag(this, '${containerId}')">×</span>
                </span>
            `).join('');

            const optionsHtml = options.map(opt => {
                const isSelected = selected.includes(opt.id || opt);
                const value = opt.id || opt;
                const label = opt.name ? `${opt.id} (${opt.name})` : (opt.label || value);
                return `<div class="tag-select-option${isSelected ? ' selected' : ''}" data-value="${value}">${label}</div>`;
            }).join('');

            return `
                <div class="tag-select-container" id="${containerId}" ${dataAttr} data-type="tag-select" data-max="${maxTags}" data-allow-custom="${allowCustom}">
                    <div class="tag-select" onclick="focusTagInput(this)">
                        ${tagsHtml}
                        <input type="text" class="tag-input" placeholder="${selected.length === 0 ? placeholder : ''}"
                               onfocus="openTagDropdown('${containerId}')"
                               oninput="filterTagOptions('${containerId}', this.value)"
                               onkeydown="handleTagKeydown(event, '${containerId}')">
                    </div>
                    <div class="tag-select-dropdown" id="${containerId}_dropdown">
                        ${optionsHtml}
                    </div>
                </div>
            `;
        }

        // Tag select helper functions
        function focusTagInput(container) {
            const input = container.querySelector('.tag-input');
            if (input) input.focus();
        }

        function openTagDropdown(containerId) {
            const dropdown = document.getElementById(`${containerId}_dropdown`);
            if (dropdown) {
                dropdown.classList.add('open');
                setTimeout(() => document.addEventListener('click', function closeDropdown(e) {
                    const container = document.getElementById(containerId);
                    if (!container || !container.contains(e.target)) {
                        dropdown.classList.remove('open');
                        document.removeEventListener('click', closeDropdown);
                    }
                }), 0);
            }
        }

        function filterTagOptions(containerId, query) {
            const dropdown = document.getElementById(`${containerId}_dropdown`);
            if (!dropdown) return;
            const options = dropdown.querySelectorAll('.tag-select-option');
            const q = query.toLowerCase();
            options.forEach(opt => {
                const text = opt.textContent.toLowerCase();
                opt.style.display = text.includes(q) ? '' : 'none';
            });
            dropdown.classList.add('open');
        }

        function handleTagKeydown(event, containerId) {
            const container = document.getElementById(containerId);
            const dropdown = document.getElementById(`${containerId}_dropdown`);
            const input = event.target;

            if (event.key === 'Backspace' && input.value === '') {
                const tags = container.querySelectorAll('.tag');
                if (tags.length > 0) {
                    tags[tags.length - 1].remove();
                    updateTagInputPlaceholder(container);
                }
            } else if (event.key === 'Enter') {
                event.preventDefault();
                const highlighted = dropdown?.querySelector('.tag-select-option.highlighted:not([style*="display: none"])');
                if (highlighted) {
                    selectTagOption(containerId, highlighted.dataset.value);
                } else if (container.dataset.allowCustom === 'true' && input.value) {
                    addTagValue(containerId, input.value);
                    input.value = '';
                }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                navigateTagOptions(dropdown, 1);
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                navigateTagOptions(dropdown, -1);
            } else if (event.key === 'Escape') {
                dropdown?.classList.remove('open');
            }
        }

        function navigateTagOptions(dropdown, direction) {
            if (!dropdown) return;
            const options = Array.from(dropdown.querySelectorAll('.tag-select-option:not([style*="display: none"])'));
            if (options.length === 0) return;
            const current = dropdown.querySelector('.tag-select-option.highlighted');
            let idx = current ? options.indexOf(current) : -1;
            if (current) current.classList.remove('highlighted');
            idx = (idx + direction + options.length) % options.length;
            options[idx]?.classList.add('highlighted');
            options[idx]?.scrollIntoView({ block: 'nearest' });
        }

        function selectTagOption(containerId, value) {
            const container = document.getElementById(containerId);
            if (!container) return;
            const existing = container.querySelector(`.tag[data-value="${value}"]`);
            if (existing) return;
            const maxTags = parseInt(container.dataset.max) || 0;
            const currentTags = container.querySelectorAll('.tag').length;
            if (maxTags > 0 && currentTags >= maxTags) return;
            addTagValue(containerId, value);
            const dropdown = document.getElementById(`${containerId}_dropdown`);
            const option = dropdown?.querySelector(`.tag-select-option[data-value="${value}"]`);
            if (option) option.classList.add('selected');
            const input = container.querySelector('.tag-input');
            if (input) { input.value = ''; input.focus(); }
            dropdown?.classList.remove('open');
        }

        function addTagValue(containerId, value) {
            const container = document.getElementById(containerId);
            const tagSelect = container?.querySelector('.tag-select');
            const input = tagSelect?.querySelector('.tag-input');
            if (!tagSelect || !input) return;
            const tag = document.createElement('span');
            tag.className = 'tag';
            tag.dataset.value = value;
            tag.innerHTML = `${value}<span class="tag-remove" onclick="removeTag(this, '${containerId}')">×</span>`;
            tagSelect.insertBefore(tag, input);
            updateTagInputPlaceholder(container);
        }

        function removeTag(removeBtn, containerId) {
            const tag = removeBtn.parentElement;
            const value = tag.dataset.value;
            tag.remove();
            const container = document.getElementById(containerId);
            updateTagInputPlaceholder(container);
            const dropdown = document.getElementById(`${containerId}_dropdown`);
            const option = dropdown?.querySelector(`.tag-select-option[data-value="${value}"]`);
            if (option) option.classList.remove('selected');
        }

        function updateTagInputPlaceholder(container) {
            const tags = container.querySelectorAll('.tag');
            const input = container.querySelector('.tag-input');
            if (input) input.placeholder = tags.length === 0 ? 'Select...' : '';
        }

        function getTagSelectValues(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return [];
            return Array.from(container.querySelectorAll('.tag')).map(t => t.dataset.value);
        }

        // Initialize tag select dropdowns with click handlers
        document.addEventListener('click', function(e) {
            const option = e.target.closest('.tag-select-option');
            if (option) {
                const dropdown = option.closest('.tag-select-dropdown');
                const containerId = dropdown?.id.replace('_dropdown', '');
                if (containerId) selectTagOption(containerId, option.dataset.value);
            }
        });

        // =====================
        // Options Editor (type-specific options for each data_type)
        // =====================
        function renderOptionsEditor(dataType, currentOptions, prefix) {
            const optionsType = OPTIONS_TYPES[dataType] || 'string_options';
            const opts = currentOptions || { type: optionsType };

            switch (optionsType) {
                case 'string_options':
                    return renderStringOptions(opts, prefix);
                case 'number_options':
                    return renderNumberOptions(opts, prefix);
                case 'boolean_options':
                    return renderBooleanOptions(opts, prefix);
                case 'object_options':
                    return renderObjectOptions(opts, prefix);
                case 'relation_options':
                    return renderRelationOptions(opts, prefix);
                case 'unique_options':
                    return renderUniqueOptions(opts, prefix);
                case 'function_options':
                    return renderFunctionOptions(opts, prefix);
                default:
                    return `<div class="form-hint">No options for ${dataType}</div>`;
            }
        }

        function renderStringOptions(opts, prefix) {
            const values = (opts.values || []).join('\n');
            return `
                <table class="prop-table" style="width:100%">
                    <tr>
                        <td class="prop-name">values</td>
                        <td class="prop-edit">
                            <textarea class="form-textarea" data-option="values" rows="3"
                                placeholder="One value per line">${values}</textarea>
                            <div class="form-hint">Predefined choices (one per line)</div>
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">allow_custom</td>
                        <td class="prop-edit">
                            <label class="toggle-switch">
                                <input type="checkbox" data-option="allow_custom" ${opts.allow_custom ? 'checked' : ''}>
                                <span class="toggle-slider"></span>
                            </label>
                            <span style="margin-left:8px;font-size:11px;color:#6b7280">Allow free text input</span>
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">min_length</td>
                        <td class="prop-edit">
                            <input type="number" class="form-input" data-option="min_length" value="${opts.min_length || ''}" min="0">
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">max_length</td>
                        <td class="prop-edit">
                            <input type="number" class="form-input" data-option="max_length" value="${opts.max_length || ''}" min="0">
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">pattern</td>
                        <td class="prop-edit">
                            <input type="text" class="form-input" data-option="pattern" value="${escapeHtml(opts.pattern || '')}" placeholder="^[a-z]+$">
                            <div class="form-hint">Regex validation pattern</div>
                        </td>
                    </tr>
                </table>
            `;
        }

        function renderNumberOptions(opts, prefix) {
            const values = (opts.values || []).join(', ');
            return `
                <table class="prop-table" style="width:100%">
                    <tr>
                        <td class="prop-name">min</td>
                        <td class="prop-edit">
                            <input type="number" class="form-input" data-option="min" value="${opts.min ?? ''}" step="any">
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">max</td>
                        <td class="prop-edit">
                            <input type="number" class="form-input" data-option="max" value="${opts.max ?? ''}" step="any">
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">step</td>
                        <td class="prop-edit">
                            <input type="number" class="form-input" data-option="step" value="${opts.step ?? 1}" step="any">
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">values</td>
                        <td class="prop-edit">
                            <input type="text" class="form-input" data-option="values" value="${values}" placeholder="10, 20, 50, 100">
                            <div class="form-hint">Predefined choices (comma-separated)</div>
                        </td>
                    </tr>
                </table>
            `;
        }

        function renderBooleanOptions(opts, prefix) {
            return `
                <table class="prop-table" style="width:100%">
                    <tr>
                        <td class="prop-name">true_label</td>
                        <td class="prop-edit">
                            <input type="text" class="form-input" data-option="true_label" value="${escapeHtml(opts.true_label || 'Yes')}">
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">false_label</td>
                        <td class="prop-edit">
                            <input type="text" class="form-input" data-option="false_label" value="${escapeHtml(opts.false_label || 'No')}">
                        </td>
                    </tr>
                </table>
            `;
        }

        function renderObjectOptions(opts, prefix) {
            return `
                <table class="prop-table" style="width:100%">
                    <tr>
                        <td class="prop-name">embedded</td>
                        <td class="prop-edit">
                            <label class="toggle-switch">
                                <input type="checkbox" data-option="embedded" ${opts.embedded !== false ? 'checked' : ''}>
                                <span class="toggle-slider"></span>
                            </label>
                            <span style="margin-left:8px;font-size:11px;color:#6b7280">Store inline (vs reference)</span>
                        </td>
                    </tr>
                </table>
            `;
        }

        function renderRelationOptions(opts, prefix) {
            return `
                <table class="prop-table" style="width:100%">
                    <tr>
                        <td class="prop-name">display_field</td>
                        <td class="prop-edit">
                            <input type="text" class="form-input" data-option="display_field" value="${escapeHtml(opts.display_field || 'name')}" placeholder="name">
                            <div class="form-hint">Field to show in dropdown</div>
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">sort_by</td>
                        <td class="prop-edit">
                            <input type="text" class="form-input" data-option="sort_by" value="${escapeHtml(opts.sort_by || '')}" placeholder="name">
                        </td>
                    </tr>
                </table>
            `;
        }

        function renderUniqueOptions(opts, prefix) {
            return `
                <table class="prop-table" style="width:100%">
                    <tr>
                        <td class="prop-name">generator</td>
                        <td class="prop-edit">
                            <select class="form-select" data-option="generator">
                                <option value="uuid" ${opts.generator === 'uuid' ? 'selected' : ''}>UUID</option>
                                <option value="auto_increment" ${opts.generator === 'auto_increment' ? 'selected' : ''}>Auto Increment</option>
                                <option value="custom" ${opts.generator === 'custom' ? 'selected' : ''}>Custom Function</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">prefix</td>
                        <td class="prop-edit">
                            <input type="text" class="form-input" data-option="prefix" value="${escapeHtml(opts.prefix || '')}" placeholder="USR-">
                        </td>
                    </tr>
                </table>
            `;
        }

        function renderFunctionOptions(opts, prefix) {
            const funcTypes = Object.keys(functionConfig.typeMap || {});
            const typeOptions = funcTypes.map(t =>
                `<option value="${t}" ${opts.function_type === t ? 'selected' : ''}>${t}</option>`
            ).join('');

            const allFuncs = Object.keys(functionConfig.functions || {});
            const funcOptions = allFuncs.map(f =>
                `<option value="${f}" ${opts.function_name === f ? 'selected' : ''}>${f}</option>`
            ).join('');

            return `
                <table class="prop-table" style="width:100%">
                    <tr>
                        <td class="prop-name">function_type</td>
                        <td class="prop-edit">
                            <select class="form-select" data-option="function_type">
                                <option value="">-- Select type --</option>
                                ${typeOptions}
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <td class="prop-name">function_name</td>
                        <td class="prop-edit">
                            <select class="form-select" data-option="function_name">
                                <option value="">-- Select function --</option>
                                ${funcOptions}
                            </select>
                        </td>
                    </tr>
                </table>
            `;
        }

        // Collect options from the options editor container
        function collectOptionsFromEditor(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return null;

            const options = {};
            container.querySelectorAll('[data-option]').forEach(el => {
                const key = el.dataset.option;
                let value;

                if (el.type === 'checkbox') {
                    value = el.checked;
                } else if (el.type === 'number') {
                    value = el.value ? parseFloat(el.value) : null;
                } else if (el.tagName === 'TEXTAREA') {
                    // Split by newlines for array values
                    value = el.value.split('\n').map(v => v.trim()).filter(v => v);
                    if (value.length === 0) value = null;
                } else if (key === 'values' && el.tagName === 'INPUT') {
                    // Comma-separated for number values
                    value = el.value.split(',').map(v => v.trim()).filter(v => v).map(v => parseFloat(v) || v);
                    if (value.length === 0) value = null;
                } else {
                    value = el.value || null;
                }

                if (value !== null && value !== '') {
                    options[key] = value;
                }
            });

            return Object.keys(options).length > 0 ? options : null;
        }

        // =====================
        // Single Value Editor
        // =====================
        function renderSingleValueEditor(prop, value) {
            const dataType = prop.data_type || 'string';
            const editor = prop.editor?.type || prop.editor || getDefaultEditor(dataType);
            const enumValues = prop.enum_values || [];
            const safeValue = value !== undefined && value !== null ? String(value).replace(/"/g, '&quot;') : '';

            // Special handling for "editor" property - show key-value editor with editor type select
            if (prop.key === 'editor' && dataType === 'object') {
                return renderEditorPropertyEditor(prop, value);
            }

            // Special handling for "default_value" when editing @prop - use dynamic editor based on data_type
            // Skip if this is already a dynamic render (prop._isDynamicRender flag)
            if (prop.key === 'default_value' && editingClassId === '@prop' && !prop._isDynamicRender) {
                // Use the same editor as the property's data_type would use
                return `<div id="default_value_editor_container">${renderDefaultValueEditor(value)}</div>`;
            }

            if (dataType === 'boolean' || editor === 'toggle') {
                const checked = value === true || value === 'true';
                return `
                    <label class="toggle-switch">
                        <input type="checkbox" data-prop="${prop.key}" data-type="boolean" ${checked ? 'checked' : ''}>
                        <span class="toggle-slider"></span>
                    </label>
                `;
            }

            if (dataType === 'enum' || editor === 'select') {
                // Special handling: when data_type changes in @prop, update default_value editor
                const extraOnChange = (prop.key === 'data_type' && editingClassId === '@prop')
                    ? 'updateDefaultValueEditor();'
                    : '';
                return `
                    <select class="form-select" data-prop="${prop.key}" data-type="enum" onblur="validateField(this)" onchange="validateField(this);${extraOnChange}">
                        <option value="">-- Select --</option>
                        ${enumValues.map(v => `<option value="${v}" ${value === v ? 'selected' : ''}>${v}</option>`).join('')}
                    </select>
                `;
            }

            if (editor === 'textarea') {
                return `<textarea class="form-textarea" data-prop="${prop.key}" data-type="string" onblur="validateField(this)">${safeValue}</textarea>`;
            }

            // For generic object without class, use JSON textarea editor
            if (dataType === 'object' && !prop.object_class_id) {
                const jsonVal = value !== undefined && value !== null ?
                    (typeof value === 'object' ? JSON.stringify(value, null, 2) : value) : '';
                return `<textarea class="form-textarea json-editor" data-prop="${prop.key}" data-type="json" placeholder="Enter JSON object" onblur="validateField(this)">${jsonVal}</textarea>`;
            }

            const inputType = (dataType === 'number' || dataType === 'float') ? 'number' :
                              (dataType === 'date') ? 'date' :
                              (dataType === 'datetime') ? 'datetime-local' : 'text';
            const step = dataType === 'float' ? 'step="any"' : '';

            return `<input type="${inputType}" class="form-input" data-prop="${prop.key}" data-type="${dataType}" value="${safeValue}" ${step} onblur="validateField(this)">`;
        }

        // =====================
        // Editor Property Editor (special for @prop.editor)
        // =====================
        function renderEditorPropertyEditor(prop, value) {
            const obj = typeof value === 'object' && value !== null ? value : { type: 'text' };
            const editorType = obj.type || 'text';
            const otherKeys = Object.keys(obj).filter(k => k !== 'type');

            // Get available editors
            const allEditors = editorConfig?.editors || {};
            const editorNames = Object.keys(allEditors);

            let html = `<div class="keyvalue-editor" data-prop="${prop.key}" data-type="editor-object">`;

            // Editor type selector
            html += `<div class="keyvalue-row">
                <div class="keyvalue-key"><label style="font-size:12px;color:#6b7280">type</label></div>
                <div class="keyvalue-value">
                    <select class="form-select" data-editor-key="type" onchange="updateEditorOptions(this)">
                        ${editorNames.map(e => `<option value="${e}" ${editorType === e ? 'selected' : ''}>${e}</option>`).join('')}
                    </select>
                </div>
            </div>`;

            // Other options
            html += `<div class="editor-options" id="editorOptions_${prop.key}">`;
            for (const key of otherKeys) {
                const val = typeof obj[key] === 'object' ? JSON.stringify(obj[key]) : obj[key];
                html += renderKeyValueRow(prop.key, key, val, true);
            }
            html += `</div>`;

            html += `<div class="keyvalue-actions">
                <button type="button" class="btn btn-ghost btn-xs" onclick="addEditorOption('${prop.key}')">+ Add Option</button>
            </div>`;
            html += `</div>`;

            return html;
        }

        // =====================
        // Key-Value Editor (generic object without class)
        // =====================
        function renderKeyValueEditor(prop, value) {
            const obj = typeof value === 'object' && value !== null ? value : {};
            const keys = Object.keys(obj);

            let html = `<div class="keyvalue-editor" data-prop="${prop.key}" data-type="keyvalue">`;
            html += `<div class="keyvalue-items" id="kv_${prop.key}">`;

            for (const key of keys) {
                const val = typeof obj[key] === 'object' ? JSON.stringify(obj[key]) : obj[key];
                html += renderKeyValueRow(prop.key, key, val, false);
            }

            html += `</div>`;
            html += `<div class="keyvalue-actions">
                <button type="button" class="btn btn-ghost btn-xs" onclick="addKeyValueRow('${prop.key}')">+ Add Key</button>
            </div>`;
            html += `</div>`;

            return html;
        }

        function renderKeyValueRow(propKey, key, value, isEditorOption = false) {
            const safeKey = key.replace(/"/g, '&quot;');
            const safeVal = String(value).replace(/"/g, '&quot;');
            const dataAttr = isEditorOption ? 'data-editor-key' : 'data-kv-key';

            return `<div class="keyvalue-row">
                <div class="keyvalue-key">
                    <input type="text" value="${safeKey}" ${dataAttr}="key" placeholder="key">
                </div>
                <div class="keyvalue-value">
                    <input type="text" value="${safeVal}" ${dataAttr}="value" placeholder="value">
                </div>
                <button type="button" class="keyvalue-remove" onclick="this.closest('.keyvalue-row').remove()">×</button>
            </div>`;
        }

        function addKeyValueRow(propKey) {
            const container = document.getElementById(`kv_${propKey}`);
            const div = document.createElement('div');
            div.innerHTML = renderKeyValueRow(propKey, '', '', false);
            container.appendChild(div.firstElementChild);
        }

        function addEditorOption(propKey) {
            const container = document.getElementById(`editorOptions_${propKey}`);
            const div = document.createElement('div');
            div.innerHTML = renderKeyValueRow(propKey, '', '', true);
            container.appendChild(div.firstElementChild);
        }

        function updateEditorOptions(selectEl) {
            // Could show/hide relevant options based on editor type
            const editorType = selectEl.value;
            console.log('Editor type changed to:', editorType);
        }

        function getDefaultEditor(dataType) {
            const map = {
                'string': 'text', 'number': 'number', 'float': 'number',
                'boolean': 'toggle', 'date': 'date', 'datetime': 'datetime',
                'enum': 'select', 'object': 'json', 'relation': 'reference'
            };
            return map[dataType] || 'text';
        }

        // =====================
        // Dynamic Default Value Editor (for @prop)
        // Reuses the same editor logic as renderSingleValueEditor
        // =====================
        function renderDefaultValueEditor(value) {
            // Build a virtual prop based on current form values (data_type, enum_values, object_class_id, etc.)
            const virtualProp = buildVirtualPropFromForm('default_value');
            return renderSingleValueEditor(virtualProp, value);
        }

        function buildVirtualPropFromForm(key) {
            // Get values from form inputs, falling back to editingObject for initial render
            const getFormValue = (propName) => {
                const el = document.querySelector(`[data-prop="${propName}"]`);
                if (el) {
                    if (el.type === 'checkbox') return el.checked;
                    if (el.dataset.type === 'json' || el.dataset.type === 'array') {
                        try { return JSON.parse(el.value); } catch (e) { return el.value; }
                    }
                    return el.value || undefined;
                }
                // Fall back to editingObject for initial render (before DOM exists)
                return editingObject?.[propName];
            };

            return {
                key: key,
                data_type: getFormValue('data_type') || 'string',
                enum_values: getFormValue('enum_values'),
                object_class_id: getFormValue('object_class_id'),
                is_array: getFormValue('is_array'),
                editor: getFormValue('editor'),
                required: false, // default_value itself is not required
                _isDynamicRender: true, // Flag to prevent recursion
            };
        }

        function updateDefaultValueEditor() {
            const container = document.getElementById('default_value_editor_container');
            if (!container) return;

            const currentValue = getCurrentDefaultValue();
            container.innerHTML = renderDefaultValueEditor(currentValue);
        }

        function getCurrentDefaultValue() {
            // Try to get current value from the existing editor
            const boolInput = document.querySelector('[data-prop="default_value"][type="checkbox"]');
            if (boolInput) return boolInput.checked;

            const input = document.querySelector('[data-prop="default_value"]');
            if (!input) return undefined;

            const type = input.dataset.type;
            if (type === 'json') {
                try {
                    return JSON.parse(input.value);
                } catch (e) {
                    return input.value;
                }
            }
            if (type === 'number' || type === 'float') {
                return input.value !== '' ? parseFloat(input.value) : undefined;
            }
            return input.value || undefined;
        }

        // =====================
        // Array Editor
        // =====================
        async function renderArrayEditor(prop, value, nestLevel) {
            const arr = Array.isArray(value) ? value : [];
            const itemType = prop.data_type || 'string';
            // Handle object_class_id as array - get primary class
            const relatedClasses = Array.isArray(prop.object_class_id) ? prop.object_class_id : (prop.object_class_id ? [prop.object_class_id] : []);
            const relatedClass = relatedClasses[0] || null;
            const propKey = prop.key;

            let html = `<div class="array-editor" data-prop="${propKey}" data-type="array" data-item-type="${itemType}" data-related-class="${relatedClass || ''}">`;
            html += `<div class="array-items" id="array_${propKey}">`;

            for (let idx = 0; idx < arr.length; idx++) {
                html += await renderArrayItem(prop, arr[idx], idx, nestLevel);
            }

            html += `</div>`;
            html += `<div class="array-actions">
                <button type="button" class="btn btn-primary btn-xs" onclick="addArrayItem('${propKey}')">+ Add Item</button>
            </div></div>`;

            return html;
        }

        async function renderArrayItem(prop, value, index, nestLevel) {
            const itemType = prop.data_type || 'string';
            const relatedClass = prop.object_class_id;
            const propKey = prop.key;

            let html = `<div class="array-item" data-index="${index}">`;
            html += `<span class="array-index">[${index}]</span>`;
            html += `<div class="array-item-content">`;

            if ((itemType === 'object' || relatedClass) && relatedClass) {
                html += await renderNestedObjectEditorInline(prop, value, nestLevel + 1, index);
            } else {
                const safeVal = value !== undefined && value !== null ? String(value).replace(/"/g, '&quot;') : '';
                const inputType = (itemType === 'number' || itemType === 'float') ? 'number' : 'text';
                html += `<input type="${inputType}" class="form-input" data-array-item="${propKey}" data-index="${index}" value="${safeVal}">`;
            }

            html += `</div>`;
            html += `<button type="button" class="btn btn-danger btn-xs array-item-remove" onclick="removeArrayItem(this)">×</button>`;
            html += `</div>`;

            return html;
        }

        async function addArrayItem(propKey) {
            const container = document.getElementById(`array_${propKey}`);
            const editor = container.closest('.array-editor');
            const itemType = editor.dataset.itemType;
            const relatedClass = editor.dataset.relatedClass;
            const index = container.children.length;

            const prop = { key: propKey, data_type: itemType, object_class_id: relatedClass };
            const defaultValue = (itemType === 'object' && relatedClass) ? {} : '';

            const div = document.createElement('div');
            div.innerHTML = await renderArrayItem(prop, defaultValue, index, 0);
            container.appendChild(div.firstElementChild);
        }

        function removeArrayItem(btn) {
            btn.closest('.array-item').remove();
            const container = btn.closest('.array-items');
            container.querySelectorAll('.array-item').forEach((item, idx) => {
                item.dataset.index = idx;
                item.querySelector('.array-index').textContent = `[${idx}]`;
                item.querySelectorAll('[data-index]').forEach(input => input.dataset.index = idx);
            });
        }

        // =====================
        // Nested Object Editor
        // =====================
        async function renderNestedObjectEditor(prop, value, nestLevel) {
            const relatedClass = prop.object_class_id;
            const obj = typeof value === 'object' && value !== null ? value : {};
            const meta = await getClassMeta(relatedClass);

            if (!meta) {
                const jsonVal = JSON.stringify(obj, null, 2);
                return `
                    <div class="form-hint">Class "${relatedClass}" not found. Using JSON editor.</div>
                    <textarea class="form-textarea json-editor" data-prop="${prop.key}" data-type="json">${jsonVal}</textarea>
                `;
            }

            const nestedProps = meta.props || [];
            const nestedPropsArray = Array.isArray(nestedProps) ? nestedProps : Object.values(nestedProps);
            const nestClass = `nested-level-${Math.min(nestLevel + 1, 3)}`;

            let html = `<div class="object-editor ${nestClass}" data-prop="${prop.key}" data-type="nested-object" data-class="${relatedClass}">`;
            html += `<div class="form-hint" style="margin-bottom:8px">Type: ${relatedClass}</div>`;

            for (const nestedProp of nestedPropsArray) {
                const nestedKey = `${prop.key}.${nestedProp.key}`;
                const nestedVal = obj[nestedProp.key];

                html += `<div class="prop-row" style="margin-bottom:8px">`;
                html += `<div class="prop-key" style="min-width:100px;font-size:12px">${nestedProp.label || nestedProp.key}</div>`;
                html += `<div class="prop-value">`;

                if (nestedProp.data_type === 'boolean') {
                    const checked = nestedVal === true;
                    html += `<label class="toggle-switch"><input type="checkbox" data-nested="${nestedKey}" data-type="boolean" ${checked ? 'checked' : ''}><span class="toggle-slider"></span></label>`;
                } else if (nestedProp.data_type === 'enum' && nestedProp.enum_values) {
                    html += `<select class="form-select" data-nested="${nestedKey}" data-type="enum">
                        <option value="">-- Select --</option>
                        ${nestedProp.enum_values.map(v => `<option value="${v}" ${nestedVal === v ? 'selected' : ''}>${v}</option>`).join('')}
                    </select>`;
                } else if (nestedProp.data_type === 'object' || (typeof nestedVal === 'object' && nestedVal !== null && !Array.isArray(nestedVal))) {
                    // Object type - use JSON
                    const jsonVal = nestedVal !== undefined && nestedVal !== null ? JSON.stringify(nestedVal) : '';
                    html += `<input type="text" class="form-input" data-nested="${nestedKey}" data-type="object" value="${jsonVal.replace(/"/g, '&quot;')}" placeholder="JSON object">`;
                } else if (nestedProp.is_array || Array.isArray(nestedVal)) {
                    // Array type - use JSON
                    const jsonVal = Array.isArray(nestedVal) ? JSON.stringify(nestedVal) : '[]';
                    html += `<input type="text" class="form-input" data-nested="${nestedKey}" data-type="array" value="${jsonVal.replace(/"/g, '&quot;')}" placeholder="JSON array">`;
                } else {
                    const safeVal = nestedVal !== undefined && nestedVal !== null ? String(nestedVal).replace(/"/g, '&quot;') : '';
                    html += `<input type="text" class="form-input" data-nested="${nestedKey}" data-type="${nestedProp.data_type || 'string'}" value="${safeVal}">`;
                }

                html += `</div></div>`;
            }

            html += `</div>`;
            return html;
        }

        async function renderNestedObjectEditorInline(prop, value, nestLevel, arrayIndex) {
            // Handle object_class_id as array - get primary class
            const relatedClasses = Array.isArray(prop.object_class_id) ? prop.object_class_id : (prop.object_class_id ? [prop.object_class_id] : []);
            const relatedClass = relatedClasses[0] || null;
            const obj = typeof value === 'object' && value !== null ? value : {};
            const meta = await getClassMeta(relatedClass);

            if (!meta) {
                const jsonVal = JSON.stringify(obj, null, 2);
                return `<textarea class="form-textarea json-editor" data-array-object="${prop.key}" data-index="${arrayIndex}">${jsonVal}</textarea>`;
            }

            const nestedProps = meta.props || [];
            const nestedPropsArray = Array.isArray(nestedProps) ? nestedProps : Object.values(nestedProps);
            const nestClass = `nested-level-${Math.min(nestLevel, 3)}`;

            let html = `<div class="object-editor ${nestClass}" data-array-object="${prop.key}" data-index="${arrayIndex}" data-class="${relatedClass}">`;

            for (const nestedProp of nestedPropsArray) {
                const nestedKey = `${prop.key}[${arrayIndex}].${nestedProp.key}`;
                const nestedVal = obj[nestedProp.key];

                html += `<div class="prop-row" style="margin-bottom:8px">`;
                html += `<div class="prop-key" style="min-width:100px;font-size:12px">${nestedProp.label || nestedProp.key}</div>`;
                html += `<div class="prop-value">`;

                if (nestedProp.data_type === 'boolean') {
                    const checked = nestedVal === true;
                    html += `<label class="toggle-switch"><input type="checkbox" data-nested="${nestedKey}" data-type="boolean" ${checked ? 'checked' : ''}><span class="toggle-slider"></span></label>`;
                } else if (nestedProp.data_type === 'enum' && nestedProp.enum_values) {
                    html += `<select class="form-select" data-nested="${nestedKey}" data-type="enum">
                        <option value="">-- Select --</option>
                        ${nestedProp.enum_values.map(v => `<option value="${v}" ${nestedVal === v ? 'selected' : ''}>${v}</option>`).join('')}
                    </select>`;
                } else if (nestedProp.data_type === 'object' || (typeof nestedVal === 'object' && nestedVal !== null && !Array.isArray(nestedVal))) {
                    // Object type - use JSON
                    const jsonVal = nestedVal !== undefined && nestedVal !== null ? JSON.stringify(nestedVal) : '';
                    html += `<input type="text" class="form-input" data-nested="${nestedKey}" data-type="object" value="${jsonVal.replace(/"/g, '&quot;')}" placeholder="JSON object">`;
                } else if (nestedProp.is_array || Array.isArray(nestedVal)) {
                    // Array type - use JSON
                    const jsonVal = Array.isArray(nestedVal) ? JSON.stringify(nestedVal) : '[]';
                    html += `<input type="text" class="form-input" data-nested="${nestedKey}" data-type="array" value="${jsonVal.replace(/"/g, '&quot;')}" placeholder="JSON array">`;
                } else {
                    const safeVal = nestedVal !== undefined && nestedVal !== null ? String(nestedVal).replace(/"/g, '&quot;') : '';
                    html += `<input type="text" class="form-input" data-nested="${nestedKey}" data-type="${nestedProp.data_type || 'string'}" value="${safeVal}">`;
                }

                html += `</div></div>`;
            }

            html += `</div>`;
            return html;
        }

        // =====================
        // Relation Editor
        // =====================
        async function renderRelationEditor(prop, value) {
            const relatedClass = prop.object_class_id || 'unknown';
            const safeVal = value || '';

            // For @class relations (like extends_id), show a dropdown with available classes
            if (relatedClass === '@class') {
                // Use allClassesList which is populated by loadClasses()
                // Include all classes (system and user-defined) so user can extend any class
                const classes = allClassesList;
                let options = '<option value="">-- None --</option>';
                for (const cls of classes) {
                    const selected = safeVal === cls.id ? 'selected' : '';
                    const label = cls.name && cls.name !== cls.id ? `${cls.id} (${cls.name})` : cls.id;
                    options += `<option value="${cls.id}" ${selected}>${label}</option>`;
                }
                return `
                    <select class="form-select" data-prop="${prop.key}" data-type="relation" style="max-width:300px">
                        ${options}
                    </select>
                    <div class="form-hint">Select parent class to inherit properties from</div>
                `;
            }

            // For other relations, show input with browse button
            return `
                <div class="relation-badge">
                    <span>→ ${relatedClass}:</span>
                    <input type="text" class="form-input" style="flex:1;max-width:200px" data-prop="${prop.key}" data-type="relation" data-related-class="${relatedClass}" value="${safeVal}" placeholder="Enter ID">
                    <button type="button" class="btn btn-ghost btn-xs" onclick="browseRelation('${prop.key}', '${relatedClass}')">Browse</button>
                </div>
            `;
        }

        async function browseRelation(propKey, classId) {
            try {
                const objects = await api('GET', `/store/${classId}`);
                if (!objects || objects.length === 0) {
                    showToast(`No ${classId} objects found`, 'error');
                    return;
                }
                const options = objects.map(o => `${o.id} - ${o.name || o.id}`).join('\n');
                const selected = prompt(`Select ${classId} ID:\n\nAvailable:\n${options}`);
                if (selected) {
                    const id = selected.split(' - ')[0].trim();
                    const input = document.querySelector(`[data-prop="${propKey}"][data-type="relation"]`);
                    if (input) input.value = id;
                }
            } catch (err) {
                showToast(err.message, 'error');
            }
        }

        // =====================
        // Collect Form Data
        // =====================
        function collectFormData() {
            const data = {};

            document.querySelectorAll('[data-prop]').forEach(el => {
                const key = el.dataset.prop;
                const type = el.dataset.type;

                if (type === 'array' || type === 'nested-object') return;

                // Handle key-value editor
                if (type === 'keyvalue') {
                    const obj = {};
                    el.querySelectorAll('.keyvalue-row').forEach(row => {
                        const keyInput = row.querySelector('[data-kv-key="key"]');
                        const valInput = row.querySelector('[data-kv-key="value"]');
                        if (keyInput && valInput && keyInput.value) {
                            let val = valInput.value;
                            // Try to parse as JSON for nested objects/arrays
                            try {
                                if (val.startsWith('{') || val.startsWith('[')) {
                                    val = JSON.parse(val);
                                } else if (val === 'true') val = true;
                                else if (val === 'false') val = false;
                                else if (!isNaN(val) && val !== '') val = parseFloat(val);
                            } catch (e) {}
                            obj[keyInput.value] = val;
                        }
                    });
                    if (Object.keys(obj).length > 0) data[key] = obj;
                    return;
                }

                // Handle editor-object (special for @prop.editor)
                if (type === 'editor-object') {
                    const obj = {};
                    // Get the type from the select
                    const typeSelect = el.querySelector('[data-editor-key="type"]');
                    if (typeSelect) obj.type = typeSelect.value;

                    // Get other options
                    el.querySelectorAll('.keyvalue-row').forEach(row => {
                        const keyInput = row.querySelector('[data-editor-key="key"]');
                        const valInput = row.querySelector('[data-editor-key="value"]');
                        if (keyInput && valInput && keyInput.value) {
                            let val = valInput.value;
                            try {
                                if (val.startsWith('{') || val.startsWith('[')) {
                                    val = JSON.parse(val);
                                } else if (val === 'true') val = true;
                                else if (val === 'false') val = false;
                                else if (!isNaN(val) && val !== '') val = parseFloat(val);
                            } catch (e) {}
                            obj[keyInput.value] = val;
                        }
                    });
                    data[key] = obj;
                    return;
                }

                let value;
                if (type === 'boolean') {
                    value = el.checked;
                } else if (type === 'number' || type === 'float') {
                    value = el.value !== '' ? parseFloat(el.value) : undefined;
                } else if (type === 'json' || type === 'object' || type === 'array') {
                    // Parse JSON for json/object/array types
                    try {
                        value = el.value ? JSON.parse(el.value) : undefined;
                    } catch (e) {
                        value = el.value;
                    }
                } else {
                    value = el.value || undefined;
                }

                if (value !== undefined && value !== '') data[key] = value;
            });

            document.querySelectorAll('.array-editor').forEach(editor => {
                const key = editor.dataset.prop;
                const itemType = editor.dataset.itemType;
                const relatedClass = editor.dataset.relatedClass;
                const arr = [];

                editor.querySelectorAll('.array-item').forEach(item => {
                    if (relatedClass && (itemType === 'object' || relatedClass)) {
                        const objData = {};
                        item.querySelectorAll('[data-nested]').forEach(nestedEl => {
                            const nestedKey = nestedEl.dataset.nested;
                            const match = nestedKey.match(/\[\d+\]\.(.+)$/);
                            if (match) {
                                const propName = match[1];
                                const nestedType = nestedEl.dataset.type;
                                let val;
                                if (nestedType === 'boolean') {
                                    val = nestedEl.checked;
                                } else if (nestedType === 'number' || nestedType === 'float') {
                                    val = nestedEl.value !== '' ? parseFloat(nestedEl.value) : undefined;
                                } else if (nestedType === 'object' || nestedType === 'array') {
                                    // Parse JSON for object/array types
                                    try {
                                        val = nestedEl.value ? JSON.parse(nestedEl.value) : undefined;
                                    } catch (e) {
                                        val = nestedEl.value || undefined;
                                    }
                                } else {
                                    val = nestedEl.value || undefined;
                                }
                                if (val !== undefined) objData[propName] = val;
                            }
                        });
                        if (Object.keys(objData).length > 0) arr.push(objData);
                    } else {
                        const input = item.querySelector('[data-array-item]');
                        if (input) {
                            let val = input.value;
                            if (itemType === 'number' || itemType === 'float') {
                                val = val !== '' ? parseFloat(val) : undefined;
                            }
                            if (val !== undefined && val !== '') arr.push(val);
                        }
                    }
                });

                if (arr.length > 0) data[key] = arr;
            });

            document.querySelectorAll('[data-type="nested-object"]').forEach(editor => {
                const key = editor.dataset.prop;
                const objData = {};

                editor.querySelectorAll('[data-nested]').forEach(el => {
                    const nestedKey = el.dataset.nested;
                    const propName = nestedKey.replace(key + '.', '');
                    const type = el.dataset.type;

                    let val;
                    if (type === 'boolean') {
                        val = el.checked;
                    } else if (type === 'number' || type === 'float') {
                        val = el.value !== '' ? parseFloat(el.value) : undefined;
                    } else if (type === 'object' || type === 'array') {
                        // Parse JSON for object/array types
                        try {
                            val = el.value ? JSON.parse(el.value) : undefined;
                        } catch (e) {
                            val = el.value || undefined;
                        }
                    } else {
                        val = el.value || undefined;
                    }
                    if (val !== undefined) objData[propName] = val;
                });

                if (Object.keys(objData).length > 0) data[key] = objData;
            });

            // Collect tag-select values (multi-select)
            document.querySelectorAll('[data-type="tag-select"]').forEach(container => {
                const prop = container.dataset.prop || container.querySelector('[data-prop]')?.dataset.prop;
                if (prop) {
                    const values = getTagSelectValues(container.id);
                    if (values.length > 0) data[prop] = values;
                }
            });

            // Collect options from the options editor (for @prop editing)
            const optionsContainer = document.getElementById('prop_options_container');
            if (optionsContainer) {
                const options = collectOptionsFromEditor('prop_options_container');
                if (options && Object.keys(options).length > 0) {
                    // Add the type field based on current data_type
                    const dataTypeSelect = document.querySelector('[data-prop="data_type"]');
                    if (dataTypeSelect) {
                        options.type = OPTIONS_TYPES[dataTypeSelect.value] || 'string_options';
                    }
                    data.options = options;
                }
            }

            return data;
        }

        // =====================
        // Save Object
        // =====================
        async function saveCurrentObject() {
            try {
                // Collect data from generic editor (or legacy form)
                const geContainer = document.getElementById('geContainer');
                const data = geContainer ? geCollectData(geContainer) : collectFormData();
                const classToRefresh = editingClassId || currentClassId;
                const isUpdate = editingObject && editingObject.id;

                // Always add class_id for objects (system field)
                if (currentTab !== 'classes' && editingClassId !== '@class') {
                    data.class_id = classToRefresh;
                }

                if (currentTab === 'classes' || editingClassId === '@class') {
                    if (!data.id) {
                        showToast('Class ID is required', 'error');
                        return;
                    }
                    await api('POST', '/class', data);
                    showToast(`Class "${data.id}" saved successfully`);
                    classesCache[data.id] = data;
                    closeModal();
                    loadClasses();
                } else {
                    // Use PUT for updates, POST for new objects
                    if (isUpdate) {
                        await api('PUT', `/store/${classToRefresh}/${editingObject.id}`, data);
                        showToast('Object updated successfully');
                    } else {
                        await api('POST', `/store/${classToRefresh}`, data);
                        showToast('Object created successfully');
                    }
                    closeModal();
                    // Refresh grid with the same class
                    if (currentClassId) {
                        loadObjects(currentClassId);
                    }
                }
            } catch (err) {
                showToast(err.message, 'error');
            }
        }

        // =====================
        // Delete Item
        // =====================
        async function deleteItem(id) {
            const itemType = currentTab === 'classes' ? 'class' : 'object';
            if (!confirm(`Delete ${itemType} "${id}"? This cannot be undone.`)) return;

            try {
                if (currentTab === 'classes') {
                    await api('DELETE', `/class/${id}`);
                    delete classesCache[id];
                    loadClasses();
                } else {
                    await api('DELETE', `/store/${currentClassId}/${id}`);
                    loadObjects(currentClassId);
                }
                showToast(`${itemType} "${id}" deleted`);
            } catch (err) {
                showToast(err.message, 'error');
            }
        }

        // =====================
        // Refresh & Tab Switching
        // =====================
        function refreshData() {
            if (currentTab === 'classes') {
                loadClasses();
            } else if (currentClassId) {
                loadObjects(currentClassId);
            }
        }

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', async () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentTab = tab.dataset.tab;

                if (currentTab === 'classes') {
                    currentClassId = null;
                    currentClassMeta = null;
                    loadClasses();
                } else {
                    await showObjectsTab();
                    // Check if a class is already selected
                    const selectedClass = $('#classSelect').val();
                    if (selectedClass) {
                        loadObjects(selectedClass);
                    } else {
                        showEmptyState();
                    }
                }
            });
        });

        // =====================
        // Export / History / Reset
        // =====================
        async function exportData() {
            try {
                showToast('Exporting data...', 'success');
                const result = await api('POST', '/export');

                if (result.is_new) {
                    showToast(`Export created: ${result.hash}`, 'success');
                } else {
                    showToast(`Data unchanged. Using existing export: ${result.hash}`, 'success');
                }

                // Auto-download the file
                window.open(API_BASE + result.url, '_blank');
            } catch (err) {
                showToast(err.message, 'error');
            }
        }

        async function showExportHistory() {
            document.getElementById('historyModal').classList.add('active');
            document.getElementById('historyBody').innerHTML = '<div class="loading"><div class="spinner"></div>Loading...</div>';

            try {
                const exports = await api('GET', '/exports');

                if (exports.length === 0) {
                    document.getElementById('historyBody').innerHTML = `
                        <div class="export-empty">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />
                            </svg>
                            <h3>No exports yet</h3>
                            <p>Click "Export" to create your first backup</p>
                        </div>
                    `;
                    return;
                }

                let html = '<ul class="export-list">';
                for (const exp of exports) {
                    const date = exp.exported_at ? new Date(exp.exported_at).toLocaleString() : 'Unknown';
                    const size = formatBytes(exp.size);
                    html += `
                        <li class="export-item">
                            <span class="export-hash">${exp.hash}</span>
                            <div class="export-info">
                                <div class="export-date">${date}</div>
                                <div class="export-stats">${exp.stats.classes} classes, ${exp.stats.total_objects} objects</div>
                            </div>
                            <span class="export-size">${size}</span>
                            <div class="export-actions">
                                <a href="${API_BASE}${exp.url}" class="btn btn-primary btn-xs" download>Download</a>
                                <button class="btn btn-ghost btn-xs" onclick="copyExportLink('${exp.hash}')">Copy Link</button>
                                <button class="btn btn-danger btn-xs" onclick="deleteExport('${exp.hash}')">Delete</button>
                            </div>
                        </li>
                    `;
                }
                html += '</ul>';
                document.getElementById('historyBody').innerHTML = html;
            } catch (err) {
                document.getElementById('historyBody').innerHTML = `<div class="export-empty"><p style="color:#ef4444">${err.message}</p></div>`;
            }
        }

        function closeHistoryModal() {
            document.getElementById('historyModal').classList.remove('active');
        }

        function copyExportLink(hash) {
            const url = window.location.origin + API_BASE + '/export/' + hash;
            navigator.clipboard.writeText(url).then(() => {
                showToast('Link copied to clipboard', 'success');
            }).catch(() => {
                prompt('Copy this link:', url);
            });
        }

        async function deleteExport(hash) {
            if (!confirm(`Delete export ${hash}?`)) return;

            try {
                await api('DELETE', `/export/${hash}`);
                showToast('Export deleted', 'success');
                showExportHistory(); // Refresh list
            } catch (err) {
                showToast(err.message, 'error');
            }
        }

        async function resetDatabase() {
            if (!confirm('⚠️ RESET DATABASE?\n\nThis will delete ALL user data and reload seed data.\n\nThis action cannot be undone!')) return;
            if (!confirm('Are you REALLY sure? Type "RESET" in the next prompt to confirm.')) return;

            const confirmation = prompt('Type RESET to confirm:');
            if (confirmation !== 'RESET') {
                showToast('Reset cancelled', 'error');
                return;
            }

            try {
                showToast('Resetting database...', 'success');
                const result = await api('POST', '/reset');
                showToast(`Database reset. Cleared: ${result.classes.join(', ')}`, 'success');
                loadClasses();
            } catch (err) {
                showToast(err.message, 'error');
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // =====================
        // Initialize
        // =====================
        async function init() {
            await loadFunctions();
            await loadClasses();
        }
        init();
    </script>
</body>
</html>
